{"version":3,"sources":["src/components/cat-alert/cat-alert.scss?tag=cat-alert&encapsulation=shadow","src/components/cat-alert/cat-alert.tsx","src/components/cat-badge/cat-badge.scss?tag=cat-badge&encapsulation=shadow","src/components/cat-badge/cat-badge.tsx","node_modules/loglevel/lib/loglevel.js","src/utils/breakpoints.ts","src/utils/platform.ts","src/utils/media-matcher.ts","src/components/cat-button/cat-button.scss?tag=cat-button&encapsulation=shadow","src/components/cat-button/cat-button.tsx","src/components/cat-icon/cat-icon.scss?tag=cat-icon&encapsulation=shadow","src/components/cat-icon/cat-icon.tsx","node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","node_modules/tabbable/dist/index.esm.js","node_modules/focus-trap/dist/focus-trap.esm.js","src/utils/first-tabbable.ts","src/components/cat-menu/cat-menu.scss?tag=cat-menu&encapsulation=shadow","src/components/cat-menu/cat-menu.tsx","node_modules/rxjs/dist/esm/internal/util/isFunction.js","node_modules/rxjs/dist/esm/internal/util/createErrorClass.js","node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js","node_modules/rxjs/dist/esm/internal/util/arrRemove.js","node_modules/rxjs/dist/esm/internal/Subscription.js","node_modules/rxjs/dist/esm/internal/config.js","node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js","node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js","node_modules/rxjs/dist/esm/internal/util/noop.js","node_modules/rxjs/dist/esm/internal/NotificationFactories.js","node_modules/rxjs/dist/esm/internal/util/errorContext.js","node_modules/rxjs/dist/esm/internal/Subscriber.js","node_modules/rxjs/dist/esm/internal/symbol/observable.js","node_modules/rxjs/dist/esm/internal/util/identity.js","node_modules/rxjs/dist/esm/internal/util/pipe.js","node_modules/rxjs/dist/esm/internal/Observable.js","node_modules/rxjs/dist/esm/internal/util/lift.js","node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js","node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js","node_modules/rxjs/dist/esm/internal/Subject.js","node_modules/rxjs/dist/esm/internal/observable/empty.js","node_modules/rxjs/dist/esm/internal/util/isScheduler.js","node_modules/rxjs/dist/esm/internal/util/args.js","node_modules/tslib/tslib.es6.js","node_modules/rxjs/dist/esm/internal/util/isArrayLike.js","node_modules/rxjs/dist/esm/internal/util/isPromise.js","node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js","node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js","node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js","node_modules/rxjs/dist/esm/internal/symbol/iterator.js","node_modules/rxjs/dist/esm/internal/util/isIterable.js","node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js","node_modules/rxjs/dist/esm/internal/observable/innerFrom.js","node_modules/rxjs/dist/esm/internal/util/executeSchedule.js","node_modules/rxjs/dist/esm/internal/operators/observeOn.js","node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js","node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js","node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js","node_modules/rxjs/dist/esm/internal/observable/from.js","node_modules/rxjs/dist/esm/internal/operators/map.js","node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js","node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js","node_modules/rxjs/dist/esm/internal/operators/mergeMap.js","node_modules/rxjs/dist/esm/internal/operators/mergeAll.js","node_modules/rxjs/dist/esm/internal/observable/fromEvent.js","node_modules/rxjs/dist/esm/internal/observable/merge.js","node_modules/rxjs/dist/esm/internal/operators/filter.js","node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js","node_modules/rxjs/dist/esm/internal/operators/takeUntil.js","src/components/cat-scrollable/cat-scrollable.scss?tag=cat-scrollable&encapsulation=shadow","src/components/cat-scrollable/cat-scrollable.tsx","src/components/cat-skeleton/cat-skeleton.scss?tag=cat-skeleton&encapsulation=shadow","src/components/cat-skeleton/cat-skeleton.tsx","src/components/cat-spinner/cat-spinner.scss?tag=cat-spinner&encapsulation=shadow","src/components/cat-spinner/cat-spinner.tsx","src/utils/is-touch-screen.ts","src/components/cat-tooltip/cat-tooltip.scss?tag=cat-tooltip&encapsulation=shadow","src/components/cat-tooltip/cat-tooltip.tsx"],"names":["catAlertCss","CatAlert","[object Object]","hostRef","this","color","h","part","class","cat-alert","Boolean","catBadgeCss","CatBadge","variant","size","round","pulse","cat-badge","cat-badge-round","cat-badge-pulse","root","definition","module","exports","log","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","trace","realMethod","undefined","replaceLoggingMethods","level","loggerName","i","length","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","Logger","name","defaultLevel","factory","self","currentLevel","storageKey","persistLevelIfPossible","levelNum","levelName","toUpperCase","localStorage","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","location","indexOf","exec","slice","levels","clearPersistedLevel","removeItem","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","setDefaultLevel","resetLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","_breakpoints","Breakpoints","xs","s","m","l","xl","isBreakpoint","value","includes","hasV8BreakIterator","Intl","v8BreakIterator","_a","Platform","EDGE","TRIDENT","BLINK","chrome","CSS","WEBKIT","IOS","FIREFOX","ANDROID","SAFARI","mediaQueriesForWebkitCompatibility","Set","mediaQueryStyleNode","MediaMatcher","_platform","_matchMedia","matchMedia","query","createEmptyStyleRule","has","createElement","setAttribute","head","appendChild","sheet","insertRule","add","error","catButtonCss","CatButton","_iconOnly","disabled","loading","submit","ellipsed","iconOnly","iconSuffix","mediaQueryList","removeEventListener","mediaQueryListener","_b","mediaMatcher","event","matches","addEventListener","onIconOnlyChanged","isIconButton","a11yLabel","warn","preventDefault","stopImmediatePropagation","options","button","focus","url","ref","el","href","target","urlTarget","aria-disabled","aria-label","id","buttonId","cat-button","cat-button-icon","cat-button-round","cat-button-loading","cat-button-disabled","cat-button-ellipsed","onClick","onFocus","onBlur","content","type","iconSize","spinnerSize","icon","hasPrefixIcon","hasSuffixIcon","catClick","emit","catFocus","catBlur","catIconCss","CatIcon","iconRegistry","CatIconRegistry","getInstance","innerHTML","getIcon","aria-hidden","getSide","placement","split","getAlignment","getMainAxisFromPlacement","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","commonAlign","side","isVertical","coords","computePosition","async","config","strategy","middleware","platform","isRTL","rects","getElementRects","statefulPlacement","middlewareData","fn","nextX","nextY","data","reset","initialPlacement","elements","expandPaddingObject","padding","top","right","bottom","left","getSideObjectFromPadding","rectToClientRect","rect","detectOverflow","middlewareArguments","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","altContext","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","alignment","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","getExpandedPlacements","oppositePlacement","flip","_middlewareData$flip","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","detectOverflowOptions","isBasePlacement","placements","overflow","overflows","overflowsData","push","every","_middlewareData$flip$","_middlewareData$flip2","nextIndex","index","nextPlacement","resetPlacement","_overflowsData$map$so","map","d","filter","reduce","acc","sort","a","b","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","alignmentAxis","offset","diffCoords","isWindow","toString","getWindow","node","ownerDocument","defaultView","getComputedStyle$1","getComputedStyle","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","Element","isNode","Node","isShadowRoot","OwnElement","ShadowRoot","isOverflowElement","overflowX","overflowY","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","contain","willChange","isLayoutViewport","min","Math","max","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","win","addVisualOffsets","visualViewport","offsetLeft","offsetTop","documentElement","getNodeScroll","scrollLeft","pageXOffset","scrollTop","pageYOffset","getWindowScrollBarX","isScaled","getRectRelativeToOffsetParent","isOffsetParentAnElement","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","getContainingBlock","currentNode","getDimensions","getViewportRect","html","clientWidth","clientHeight","layoutViewport","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getNearestOverflowAncestor","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","concat","updatedList","contains","parent","child","rootNode","getRootNode","next","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingParent","getClippingAncestors","clippingAncestors","canEscapeClipping","clipperElement","mainClippingAncestors","firstClippingAncestor","clippingRect","accRect","clippingAncestor","getClientRects","Array","from","autoUpdate","update","ancestorScroll","_ancestorScroll","ancestorResize","_ancestorResize","elementResize","_elementResize","animationFrame","cleanedUp","ancestors","forEach","ancestor","passive","observer","ResizeObserver","observe","frameId","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","_observer","disconnect","cancelAnimationFrame","computePosition$1","candidateSelectors","candidateSelector","join","NoElement","msMatchesSelector","webkitMatchesSelector","getCandidates","includeContainer","candidates","querySelectorAll","unshift","getCandidatesIteratively","elementsToCheck","shift","tagName","assigned","assignedElements","children","nestedCandidates","flatten","scope","validCandidate","shadowRoot","getShadowRoot","_nestedCandidates","getTabindex","isScope","tabIndex","isContentEditable","isNaN","parseInt","getAttribute","sortOrderedTabbables","documentOrder","isInput","isHiddenInput","isDetailsWithSummary","r","some","getCheckedRadio","nodes","form","checked","isTabbableRadio","radioScope","queryRadios","radioSet","escape","err","message","isRadio","isNonTabbableRadio","isZeroArea","_node$getBoundingClie","isHidden","displayCheck","visibility","isDirectSummary","nodeUnderDetails","parentElement","originalNode","isDisabledFromFieldset","item","isNodeMatchingSelectorFocusable","isNodeMatchingSelectorTabbable","sortByOrder","regularTabbables","orderedTabbables","candidateTabindex","sortable","tabbable","focusable","isTabbable","Error","focusableCandidateSelector","isFocusable","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","enumerable","_objectSpread2","source","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","configurable","writable","activeFocusTraps","trapQueue","activateTrap","trap","activeTrap","pause","trapIndex","splice","deactivateTrap","unpause","isSelectableInput","select","isEscapeEvent","keyCode","isTabEvent","delay","setTimeout","findIndex","arr","idx","valueOrHandler","_len","params","_key","getActualTarget","composedPath","createFocusTrap","userOptions","doc","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","container","tabbableNodes","find","getNodeForOption","optionValue","_len2","_key2","querySelector","getInitialFocusNode","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","tabbableOptions","focusableNodes","lastTabbableNode","nextTabbableNode","forward","nodeIdx","n","reverse","group","tryFocus","preventScroll","getReturnFocusNode","previousActiveElement","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","checkFocusIn","targetContained","Document","checkTab","destinationNode","containerIndex","containerGroup","shiftKey","startOfGroupIndex","_ref2","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref3","_destinationGroupIndex","_destinationGroup","checkKey","checkClick","addListeners","capture","removeListeners","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","clearTimeout","onDeactivate","onPostDeactivate","checkCanReturnFocus","finishDeactivation","updateContainerElements","containerElements","elementsAsArray","firstTabbable","catMenuCss","nextUniqueId","CatMenu","hide","trigger","triggerSlot","_c","contentId","_d","_e","show","keyListener","targetElements","activeIdx","activeOff","targetIdx","Host","style","display","catOpen","focusTrap.createFocusTrap","catClose","OFFSET","assign","isFunction","createErrorClass","createImpl","_super","instance","stack","ctorFunc","create","constructor","UnsubscriptionError","UnsubscriptionErrorImpl","errors","arrRemove","Subscription","initialTeardown","closed","_parentage","_finalizers","isArray","remove","initialFinalizer","finalizer","execFinalizer","teardown","_hasParent","_addParent","_removeParent","EMPTY","empty","EMPTY_SUBSCRIPTION","isSubscription","unsubscribe","onUnhandledError","onStoppedNotification","Promise","useDeprecatedSynchronousErrorHandling","useDeprecatedNextContext","timeoutProvider","handler","timeout","args","delegate","handle","reportUnhandledError","COMPLETE_NOTIFICATION","createNotification","errorNotification","nextNotification","kind","errorContext","cb","Subscriber","destination","super","isStopped","EMPTY_OBSERVER","complete","SafeSubscriber","handleStoppedNotification","_next","_error","_complete","_bind","thisArg","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","context","defaultErrorHandler","notification","subscriber","observable","Symbol","identity","pipeFromArray","fns","piped","input","prev","Observable","subscribe","_subscribe","operator","isSubscriber","_trySubscribe","sink","promiseCtor","getPromiseCtor","resolve","reject","Symbol_observable","operations","isObserver","hasLift","lift","operate","init","liftedSource","createOperatorSubscriber","onNext","onComplete","onError","onFinalize","OperatorSubscriber","shouldUnsubscribe","ObjectUnsubscribedError","ObjectUnsubscribedErrorImpl","Subject","currentObservers","observers","hasError","thrownError","subject","AnonymousSubject","_throwIfClosed","observed","_checkFinalizedStatuses","_innerSubscribe","isScheduler","schedule","last","popScheduler","pop","popNumber","defaultValue","__awaiter","_arguments","P","generator","adopt","fulfilled","step","rejected","result","done","__values","o","iterator","__await","v","__asyncGenerator","asyncIterator","g","q","verb","resume","settle","fulfill","f","__asyncValues","isArrayLike","isPromise","isInteropObservable","isAsyncIterable","createInvalidObservableTypeError","getSymbolIterator","isIterable","Symbol_iterator","readableStreamLikeToAsyncGenerator","readableStream","readableStreamLikeToAsyncGenerator_1","reader","getReader","read","releaseLock","isReadableStreamLike","innerFrom","fromInteropObservable","fromArrayLike","fromPromise","fromAsyncIterable","fromIterable","fromReadableStreamLike","obs","array","promise","iterable","asyncIterable","process","catch","asyncIterable_1","asyncIterable_1_1","e_1","e_1_1","return","executeSchedule","parentSubscription","scheduler","work","repeat","scheduleSubscription","observeOn","subscribeOn","scheduleObservable","pipe","schedulePromise","scheduleArray","scheduleIterable","scheduleAsyncIterable","scheduleReadableStreamLike","scheduled","project","callOrApply","mapOneOrManyArgs","mergeInternals","concurrent","onBeforeNext","expand","innerSubScheduler","additionalFinalizer","buffer","isComplete","checkComplete","outerNext","doInnerSub","innerComplete","innerValue","bufferedValue","mergeMap","resultSelector","Infinity","ii","mergeAll","nodeEventEmitterMethods","eventTargetMethods","jqueryMethods","fromEvent","eventName","isEventTarget","isNodeStyleEventEmitter","toCommonHandlerRegistry","isJQueryStyleEventEmitter","subTarget","addListener","removeListener","on","off","merge","sources","predicate","distinctUntilChanged","comparator","keySelector","defaultCompare","previousKey","first","currentKey","takeUntil","notifier","catScrollableCss","CatScrollable","destroyed","shadowX","shadowY","overscroll","scrolledInit","scrolledBuffer","scrollElement","scrolled","attachEmitter","scrolledLeft","scrolledRight","scrolledBottom","scrolledTop","getScrollOffset","toggleClass","scrollWrapperElement","scrollable-content","scroll-x","scroll-y","no-overscroll","emitter","isLower","classList","catSkeletonCss","CatSkeleton","effect","count","cat-skeleton","lines","--line-width","random","floor","catSpinnerCss","CatSpinner","xmlns","viewBox","cx","cy","isTouchDevice","maxTouchPoints","catTooltipCss","CatTooltip","showDelay","hideDelay","longTouchDuration","hideListener","triggerElement","tooltip","isTouchScreen","touchStartListener","touchEndListener","showListener","_f","_g","aria-describedby","hideTimeout","showTimeout","blur","touchTimeout"],"mappings":"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","sourcesContent":["@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  display: block;\n  margin-bottom: $cat-body-margin-bottom;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.cat-alert {\n  font: inherit;\n  color: cat-token-wrap(var(--text));\n  background-color: cat-token-wrap(var(--bg), $alpha: 0.1);\n  box-shadow: inset 0 0 0 1px cat-token-wrap(var(--border), $alpha: 0.2);\n  border-radius: cat-border-radius('m');\n  padding: cat-size('xs') * 0.5 cat-size('s') * 0.5;\n  width: 100%;\n}\n\n::slotted(:last-child) {\n  margin-bottom: 0 !important;\n}\n\n// ----- theme\n\n@mixin theme($theme) {\n  .cat-alert-#{$theme} {\n    --bg: #{cat-token('color.theme.#{$theme}.bg', $wrap: false)};\n    --text: #{cat-token('color.theme.#{$theme}.text', $wrap: false)};\n    @if $theme == 'secondary' {\n      --border: #{cat-token('color.theme.#{$theme}.bg', $wrap: false)};\n    } @else {\n      --border: #{cat-token('color.theme.#{$theme}.text', $wrap: false)};\n    }\n  }\n}\n\n@include theme('primary');\n@include theme('secondary');\n@include theme('success');\n@include theme('warning');\n@include theme('danger');\n","import { Component, h, Prop } from '@stencil/core';\n\n/**\n * Alerts are used to display important messages inline.\n *\n * @part alert - The content of the alert.\n */\n@Component({\n  tag: 'cat-alert',\n  styleUrl: 'cat-alert.scss',\n  shadow: true\n})\nexport class CatAlert {\n  /**\n   * The color palette of the alert.\n   */\n  @Prop() color: 'primary' | 'secondary' | 'danger' | 'success' | 'warning' = 'primary';\n\n  render() {\n    return (\n      <div\n        part=\"alert\"\n        class={{\n          'cat-alert': true,\n          [`cat-alert-${this.color}`]: Boolean(this.color)\n        }}\n      >\n        <slot></slot>\n      </div>\n    );\n  }\n}\n","@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  display: inline-flex;\n  max-width: 100%;\n  vertical-align: baseline;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.cat-badge {\n  font: inherit;\n  flex: 1 1 auto;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  border-radius: cat-border-radius('s');\n  text-decoration: none;\n  width: 100%;\n  box-sizing: border-box;\n  line-height: 1;\n  white-space: nowrap;\n\n  slot {\n    display: inline-block;\n    @include cat-ellipsis;\n  }\n}\n\n// ----- round\n\n.cat-badge-round {\n  border-radius: 10rem;\n}\n\n// ----- theme\n\n.cat-badge-filled {\n  background-color: cat-token-wrap(var(--bg));\n  color: cat-token-wrap(var(--fill));\n  font-weight: 600;\n  @include cat-font-smooth;\n}\n\n$-outline: inset 0 0 0 1px cat-token-wrap(var(--border), $alpha: 0.2);\n\n.cat-badge-outlined {\n  background-color: cat-token('color.ui.background.body');\n  box-shadow: $-outline;\n  color: cat-token-wrap(var(--text));\n}\n\n@mixin theme($theme) {\n  .cat-badge-#{$theme} {\n    --bg: #{cat-token('color.theme.#{$theme}.bg', $wrap: false)};\n    --fill: #{cat-token('color.theme.#{$theme}.fill', $wrap: false)};\n    --text: #{cat-token('color.theme.#{$theme}.text', $wrap: false)};\n    @if $theme == 'secondary' {\n      --border: #{cat-token('color.theme.#{$theme}.bg', $wrap: false)};\n    } @else {\n      --border: #{cat-token('color.theme.#{$theme}.text', $wrap: false)};\n    }\n  }\n}\n\n@include theme('primary');\n@include theme('secondary');\n@include theme('success');\n@include theme('warning');\n@include theme('danger');\n\n// ----- size\n\n@mixin size($size, $fontSize) {\n  .cat-badge-#{$size} {\n    height: cat-size($size) * 0.5;\n    min-width: cat-size($size) * 0.5;\n    font-size: cat-body-font-size($fontSize);\n    padding: 0 cat-size($size) * 0.125;\n  }\n}\n\n@include size('xs', 'xs');\n@include size('s', 'xs');\n@include size('m', 'xs');\n@include size('l', 's');\n@include size('xl', 'm');\n\n// ----- pulse\n\n$-pulse-0: 0 0 0 0 cat-token-wrap(var(--bg));\n$-pulse-70: transparent 0 0 0 0.5rem;\n$-pulse-100: transparent 0 0 0 0;\n\n.cat-badge-pulse {\n  &.cat-badge-filled {\n    animation: 1.5s ease 0s infinite normal none running pulse;\n  }\n\n  &.cat-badge-outlined {\n    animation: 1.5s ease 0s infinite normal none running pulse-outlined;\n  }\n}\n\n@keyframes pulse {\n  0% {\n    box-shadow: $-pulse-0;\n  }\n\n  70% {\n    box-shadow: $-pulse-70;\n  }\n\n  100% {\n    box-shadow: $-pulse-100;\n  }\n}\n\n@keyframes pulse-outlined {\n  0% {\n    box-shadow: $-pulse-0, $-outline;\n  }\n\n  70% {\n    box-shadow: $-pulse-70, $-outline;\n  }\n\n  100% {\n    box-shadow: $-pulse-100, $-outline;\n  }\n}\n","import { Component, h, Prop } from '@stencil/core';\n\n/**\n * Badges are used to draw attention and display statuses or counts.\n *\n * @part badge - The content of the badge.\n */\n@Component({\n  tag: 'cat-badge',\n  styleUrl: 'cat-badge.scss',\n  shadow: true\n})\nexport class CatBadge {\n  /**\n   * The rendering style of the badge.\n   */\n  @Prop() variant: 'filled' | 'outlined' = 'filled';\n\n  /**\n   * The color palette of the badge.\n   */\n  @Prop() color: 'primary' | 'secondary' | 'danger' | 'success' | 'warning' = 'primary';\n\n  /**\n   * The size of the badge.\n   */\n  @Prop() size: 'xs' | 's' | 'm' | 'l' | 'xl' = 'm';\n\n  /**\n   * Use round badge edges.\n   */\n  @Prop() round = false;\n\n  /**\n   * Draw attention to the badge with a subtle animation.\n   */\n  @Prop() pulse = false;\n\n  render() {\n    return (\n      <span\n        part=\"badge\"\n        class={{\n          'cat-badge': true,\n          'cat-badge-round': this.round,\n          'cat-badge-pulse': this.pulse,\n          [`cat-badge-${this.variant}`]: Boolean(this.variant),\n          [`cat-badge-${this.color}`]: Boolean(this.color),\n          [`cat-badge-${this.size}`]: Boolean(this.size)\n        }}\n      >\n        <slot></slot>\n      </span>\n    );\n  }\n}\n","/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","const _breakpoints = ['xs', 's', 'm', 'l', 'xl'] as const;\n\nexport type Breakpoint = typeof _breakpoints[number];\n\nexport const Breakpoints: { [breakpoint in Breakpoint]: string } = {\n  xs: '(max-width: 539.98px)',\n  s: '(max-width: 767.98px)',\n  m: '(max-width: 991.98px)',\n  l: '(max-width: 1199.98px)',\n  xl: '(max-width: 1399.98px)'\n};\n\nexport function isBreakpoint(value: unknown): value is Breakpoint {\n  return typeof value === 'string' && _breakpoints.includes(value as Breakpoint);\n}\n","// https://github.com/angular/components/blob/master/src/cdk/platform/platform.ts\n\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\nlet hasV8BreakIterator: boolean;\n\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  hasV8BreakIterator = typeof Intl !== 'undefined' && (Intl as any).v8BreakIterator;\n} catch {\n  hasV8BreakIterator = false;\n}\n\nexport class Platform {\n  /** Whether the current browser is Microsoft Edge. */\n  EDGE: boolean = /(edge)/i.test(navigator.userAgent);\n\n  /** Whether the current rendering engine is Microsoft Trident. */\n  TRIDENT: boolean = /(msie|trident)/i.test(navigator.userAgent);\n\n  // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n  /** Whether the current rendering engine is Blink. */\n  BLINK: boolean =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    !!((window as any).chrome || hasV8BreakIterator) && typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT;\n\n  // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n  // ensure that Webkit runs standalone and is not used as another engine's base.\n  /** Whether the current rendering engine is WebKit. */\n  WEBKIT: boolean = /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n\n  /** Whether the current platform is Apple iOS. */\n  IOS: boolean = /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);\n\n  // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n  // them self as Gecko-like browsers and modify the userAgent's according to that.\n  // Since we only cover one explicit Firefox case, we can simply check for Firefox\n  // instead of having an unstable check for Gecko.\n  /** Whether the current browser is Firefox. */\n  FIREFOX: boolean = /(firefox|minefield)/i.test(navigator.userAgent);\n\n  /** Whether the current platform is Android. */\n  // Trident on mobile adds the android platform to the userAgent to trick detections.\n  ANDROID: boolean = /android/i.test(navigator.userAgent) && !this.TRIDENT;\n\n  // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n  // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n  // Safari browser should also use Webkit as its layout engine.\n  /** Whether the current browser is Safari. */\n  SAFARI: boolean = /safari/i.test(navigator.userAgent) && this.WEBKIT;\n}\n","import log from 'loglevel';\nimport { Platform } from './platform';\n\n// https://github.com/angular/components/blob/master/src/cdk/layout/media-matcher.ts\n\n/** Global registry for all dynamically-created, injected media queries. */\nconst mediaQueriesForWebkitCompatibility: Set<string> = new Set<string>();\n\n/** Style tag that holds all of the dynamically-created media queries. */\nlet mediaQueryStyleNode: HTMLStyleElement | undefined;\n\n/** A utility for calling matchMedia queries. */\nexport class MediaMatcher {\n  private _platform;\n  private _matchMedia: (query: string) => MediaQueryList;\n\n  constructor() {\n    this._platform = new Platform();\n    this._matchMedia = window.matchMedia.bind(window);\n  }\n\n  /**\n   * Evaluates the given media query and returns the native MediaQueryList from which results\n   * can be retrieved.\n   * Confirms the layout engine will trigger for the selector query provided and returns the\n   * MediaQueryList for the query provided.\n   */\n  matchMedia(query: string): MediaQueryList {\n    if (this._platform.WEBKIT || this._platform.BLINK) {\n      createEmptyStyleRule(query);\n    }\n    return this._matchMedia(query);\n  }\n}\n\n/**\n * Creates an empty stylesheet that is used to work around browser inconsistencies related to\n * `matchMedia`. At the time of writing, it handles the following cases:\n * 1. On WebKit browsers, a media query has to have at least one rule in order for `matchMedia`\n * to fire. We work around it by declaring a dummy stylesheet with a `@media` declaration.\n * 2. In some cases Blink browsers will stop firing the `matchMedia` listener if none of the rules\n * inside the `@media` match existing elements on the page. We work around it by having one rule\n * targeting the `body`. See https://github.com/angular/components/issues/23546.\n */\nfunction createEmptyStyleRule(query: string) {\n  if (mediaQueriesForWebkitCompatibility.has(query)) {\n    return;\n  }\n\n  try {\n    if (!mediaQueryStyleNode) {\n      mediaQueryStyleNode = document.createElement('style');\n      mediaQueryStyleNode.setAttribute('type', 'text/css');\n      document.head.appendChild(mediaQueryStyleNode);\n    }\n    if (mediaQueryStyleNode.sheet) {\n      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);\n      mediaQueriesForWebkitCompatibility.add(query);\n    }\n  } catch (e) {\n    log.error(e);\n  }\n}\n","@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  display: inline-block;\n  max-width: 100%;\n  vertical-align: middle;\n  @include cat-select(none);\n}\n\n.cat-button {\n  font: inherit;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: none;\n  border-radius: cat-border-radius('m');\n  text-decoration: none;\n  width: 100%;\n  box-sizing: border-box;\n  cursor: pointer;\n  transition: color cat-token('time.transition.s') linear, border-color cat-token('time.transition.s') linear,\n    background-color cat-token('time.transition.s') linear, box-shadow cat-token('time.transition.s') linear;\n\n  &:focus-visible {\n    outline: $cat-focus-outline;\n    outline-offset: 1px;\n  }\n}\n\n// ----- content\n\n.cat-button-content {\n  // flex: 1 1 auto;\n  // text-align: center;\n\n  .cat-button-ellipsed & {\n    @include cat-ellipsis;\n  }\n}\n\n// ----- disabled\n\n.cat-button-disabled {\n  @include cat-disabled;\n}\n\n// ----- round\n\n.cat-button-round {\n  border-radius: 10rem;\n}\n\n// ----- loading\n\n.cat-button-loading {\n  cursor: default;\n\n  cat-spinner {\n    position: absolute;\n  }\n\n  > *:not(cat-spinner) {\n    visibility: hidden;\n  }\n}\n\n// ----- theme\n\n.cat-button-filled {\n  background-color: cat-token-wrap(var(--bg));\n  color: cat-token-wrap(var(--fill));\n  font-weight: 600;\n  @include cat-font-smooth;\n}\n\n.cat-button-outlined {\n  background-color: cat-token('color.ui.background.body');\n  box-shadow: inset 0 0 0 1px cat-token-wrap(var(--base), $alpha: 0.2);\n  color: cat-token-wrap(var(--text));\n\n  &:hover:not(.cat-button-disabled):not(.cat-button-loading) {\n    background-color: cat-token-wrap(var(--base), $alpha: 0.05);\n  }\n\n  &:active:not(.cat-button-disabled):not(.cat-button-loading) {\n    background-color: cat-token-wrap(var(--base), $alpha: 0.1);\n  }\n}\n\n.cat-button-text {\n  background-color: transparent;\n  color: cat-token-wrap(var(--text));\n  text-decoration: $cat-link-text-decoration;\n\n  &:hover:not(.cat-button-disabled):not(.cat-button-loading) {\n    text-decoration: $cat-link-text-decoration-hover;\n  }\n}\n\n@mixin theme($theme) {\n  .cat-button-#{$theme} {\n    --bg: #{cat-token('color.theme.#{$theme}.bg', $wrap: false)};\n    --fill: #{cat-token('color.theme.#{$theme}.fill', $wrap: false)};\n    --text: #{cat-token('color.theme.#{$theme}.text', $wrap: false)};\n    @if $theme == 'secondary' {\n      --base: #{cat-token('color.theme.#{$theme}.bg', $wrap: false)};\n    } @else {\n      --base: #{cat-token('color.theme.#{$theme}.text', $wrap: false)};\n    }\n\n    &:hover:not(.cat-button-disabled):not(.cat-button-loading) {\n      --bg: #{cat-token('color.theme.#{$theme}.bgHover', $wrap: false)};\n      --fill: #{cat-token('color.theme.#{$theme}.fillHover', $wrap: false)};\n      --text: #{cat-token('color.theme.#{$theme}.textHover', $wrap: false)};\n    }\n\n    &:active:not(.cat-button-disabled):not(.cat-button-loading) {\n      --bg: #{cat-token('color.theme.#{$theme}.bgActive', $wrap: false)};\n      --fill: #{cat-token('color.theme.#{$theme}.fillActive', $wrap: false)};\n      --text: #{cat-token('color.theme.#{$theme}.textActive', $wrap: false)};\n    }\n  }\n}\n\n@include theme('primary');\n@include theme('secondary');\n@include theme('success');\n@include theme('warning');\n@include theme('danger');\n\n// ----- size\n\n@mixin size($size, $fontSize, $padding) {\n  $-line-height: cat-body-line-height($fontSize);\n  $-total-height: cat-size($size);\n\n  .cat-button-#{$size} {\n    min-width: cat-size($size);\n    padding: ($-total-height - $-line-height) * 0.5 $padding;\n    @include cat-body($fontSize);\n\n    .cat-button-prefix {\n      margin-right: 0.25rem;\n    }\n\n    .cat-button-suffix {\n      margin-left: 0.25rem;\n    }\n\n    // normalize icon size for line height\n    @if $fontSize == 'm' {\n      cat-icon {\n        margin-top: -0.125rem;\n        margin-bottom: -0.125rem;\n      }\n    }\n\n    &.cat-button-icon {\n      width: $-total-height;\n      padding-left: 0;\n      padding-right: 0;\n    }\n\n    :host-context(nav) & {\n      padding-left: $cat-nav-padding-horizontal;\n      padding-right: $cat-nav-padding-horizontal;\n    }\n  }\n}\n\n@include size('xs', 's', 0.25rem);\n@include size('s', 'm', 0.5rem);\n@include size('m', 'm', 0.75rem);\n@include size('l', 'm', 1rem);\n@include size('xl', 'l', 1.25rem);\n\n// ----- context\n\n:host-context(nav) {\n  width: 100%;\n\n  .cat-button {\n    box-shadow: none;\n    border-radius: 0;\n\n    &:focus-visible {\n      outline-offset: -2px;\n    }\n  }\n\n  .cat-button-content {\n    text-align: left;\n  }\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n:host(.cat-text-left) .cat-button {\n  justify-content: left;\n}\n\n:host(.cat-text-right) .cat-button {\n  justify-content: right;\n}\n","import { Component, Event, EventEmitter, h, Listen, Method, Prop, State, Watch } from '@stencil/core';\nimport log from 'loglevel';\nimport { Breakpoint, Breakpoints, isBreakpoint } from '../../utils/breakpoints';\nimport { MediaMatcher } from '../../utils/media-matcher';\n\n/**\n * Buttons are used for interface actions.\n *\n * @part button - The native anchor or button element.\n * @part content - The textual content of the button.\n * @part prefix - The prefix icon.\n * @part suffix - The suffix icon.\n */\n@Component({\n  tag: 'cat-button',\n  styleUrl: 'cat-button.scss',\n  shadow: true\n})\nexport class CatButton {\n  private button!: HTMLButtonElement | HTMLAnchorElement;\n  private mediaMatcher?: MediaMatcher;\n  private mediaQueryList?: MediaQueryList;\n  private mediaQueryListener?: (event: MediaQueryListEvent) => void;\n\n  @State() _iconOnly = true;\n\n  /**\n   * The rendering style of the button.\n   */\n  @Prop() variant: 'filled' | 'outlined' | 'text' = 'outlined';\n\n  /**\n   * The color palette of the button.\n   */\n  @Prop() color: 'primary' | 'secondary' | 'danger' | 'success' | 'warning' = 'secondary';\n\n  /**\n   * The size of the button.\n   */\n  @Prop() size: 'xs' | 's' | 'm' | 'l' | 'xl' = 'm';\n\n  /**\n   * The name of the button, which gets paired with the button's value when\n   * submitted as part of a form. Corresponds with the native HTML name\n   * attribute.\n   */\n  @Prop() name?: string;\n\n  /**\n   * The value of the button, which gets paired with the button's name when\n   * submitted as part of a form. Corresponds with the native HTML value\n   * attribute.\n   */\n  @Prop() value?: string;\n\n  /**\n   * Specifies that the button should be disabled. A disabled button is unusable\n   * and un-clickable. Corresponds with the native HTML disabled attribute.\n   */\n  @Prop() disabled = false;\n\n  /**\n   * Displays the button in a loading state with a spinner. Just like a disabled\n   * button, an inactive button is unusable and un-clickable. However, it\n   * retains the current focus state.\n   */\n  @Prop() loading = false;\n\n  /**\n   * Allows the button to submit a form.\n   */\n  @Prop() submit = false;\n\n  /**\n   * Ellipse overflowing button content.\n   */\n  @Prop() ellipsed = true;\n\n  /**\n   * Use round button edges.\n   */\n  @Prop() round = false;\n\n  /**\n   * A destination to link to, rendered in the href attribute of a link.\n   */\n  @Prop() url?: string;\n\n  /**\n   * Specifies where to open the linked document.\n   */\n  @Prop() urlTarget?: '_blank' | '_self';\n\n  /**\n   * The name of an icon to be displayed in the button.\n   */\n  @Prop() icon?: string;\n\n  /**\n   * Hide the actual button content and only display the icon.\n   */\n  @Prop() iconOnly: boolean | Breakpoint = false;\n\n  /**\n   * Display the icon as a suffix.\n   */\n  @Prop() iconSuffix = false;\n\n  /**\n   * Adds a unique identifier for the button. Please note that with this\n   * particular component this ID is added inside the web component. If you need\n   * an ID on the HTML element, use the regular `id` attribute instead.\n   */\n  @Prop() buttonId?: string;\n\n  /**\n   * Adds accessible label for the button that is only shown for screen\n   * readers. Typically, this label text replaces the visible text on the\n   * button for users who use assistive technology.\n   */\n  @Prop({ attribute: 'a11y-label' }) a11yLabel?: string;\n\n  @Watch('iconOnly')\n  onIconOnlyChanged(value: boolean | Breakpoint): void {\n    // teardown\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.mediaQueryList?.removeEventListener('change', this.mediaQueryListener!);\n    this.mediaQueryList = undefined;\n    this.mediaQueryListener = undefined;\n    // setup\n    if (isBreakpoint(value)) {\n      this.mediaMatcher ??= new MediaMatcher();\n      this.mediaQueryList = this.mediaMatcher.matchMedia(Breakpoints[value]);\n      this.mediaQueryListener = (event: MediaQueryListEvent) => (this._iconOnly = event.matches);\n      this.mediaQueryList.addEventListener('change', this.mediaQueryListener);\n      this._iconOnly = this.mediaQueryList.matches;\n    } else {\n      this._iconOnly = value;\n    }\n  }\n\n  /**\n   * Emitted when the button is clicked.\n   */\n  @Event() catClick!: EventEmitter<MouseEvent>;\n\n  /**\n   * Emitted when the button received focus.\n   */\n  @Event() catFocus!: EventEmitter<FocusEvent>;\n\n  /**\n   * Emitted when the button loses focus.\n   */\n  @Event() catBlur!: EventEmitter<FocusEvent>;\n\n  componentWillLoad(): void {\n    this.onIconOnlyChanged(this.iconOnly);\n  }\n\n  componentWillRender(): void {\n    if (this.isIconButton && !this.a11yLabel) {\n      log.warn('[A11y] Missing ARIA label on icon button', this);\n    }\n  }\n\n  @Listen('click')\n  haltDisabledEvents(event: Event): void {\n    if (this.disabled || this.loading) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  }\n\n  /**\n   * Sets focus on the button. Use this method instead of `button.focus()`.\n   *\n   * @param options An optional object providing options to control aspects of\n   * the focusing process.\n   */\n  @Method()\n  async setFocus(options?: FocusOptions): Promise<void> {\n    this.button.focus(options);\n  }\n\n  render() {\n    if (this.url) {\n      return (\n        <a\n          ref={el => (this.button = el as HTMLAnchorElement)}\n          href={this.disabled ? undefined : this.url}\n          target={this.urlTarget}\n          aria-disabled={this.disabled ? 'true' : null}\n          aria-label={this.a11yLabel}\n          id={this.buttonId}\n          part=\"button\"\n          class={{\n            'cat-button': true,\n            'cat-button-icon': this.isIconButton,\n            'cat-button-round': this.round,\n            'cat-button-loading': this.loading,\n            'cat-button-disabled': this.disabled,\n            'cat-button-ellipsed': this.ellipsed && !this.isIconButton,\n            [`cat-button-${this.variant}`]: Boolean(this.variant),\n            [`cat-button-${this.color}`]: Boolean(this.color),\n            [`cat-button-${this.size}`]: Boolean(this.size)\n          }}\n          onClick={this.onClick.bind(this)}\n          onFocus={this.onFocus.bind(this)}\n          onBlur={this.onBlur.bind(this)}\n        >\n          {this.content}\n        </a>\n      );\n    } else {\n      return (\n        <button\n          ref={el => (this.button = el as HTMLButtonElement)}\n          type={this.submit ? 'submit' : 'button'}\n          name={this.name}\n          value={this.value}\n          disabled={this.disabled}\n          aria-disabled={this.disabled ? 'true' : null}\n          aria-label={this.a11yLabel}\n          id={this.buttonId}\n          part=\"button\"\n          class={{\n            'cat-button': true,\n            'cat-button-icon': this.isIconButton,\n            'cat-button-round': this.round ?? this.isIconButton,\n            'cat-button-loading': this.loading,\n            'cat-button-disabled': this.disabled,\n            'cat-button-ellipsed': this.ellipsed && !this.isIconButton,\n            [`cat-button-${this.variant}`]: Boolean(this.variant),\n            [`cat-button-${this.color}`]: Boolean(this.color),\n            [`cat-button-${this.size}`]: Boolean(this.size)\n          }}\n          onClick={this.onClick.bind(this)}\n          onFocus={this.onFocus.bind(this)}\n          onBlur={this.onBlur.bind(this)}\n        >\n          {this.content}\n        </button>\n      );\n    }\n  }\n\n  private get iconSize(): 'xs' | 's' | 'm' | 'l' | 'xl' {\n    switch (this.size) {\n      case 'xs':\n        return 's';\n      default:\n        return 'l';\n    }\n  }\n\n  private get spinnerSize(): 'xs' | 's' | 'm' | 'l' | 'xl' {\n    switch (this.size) {\n      case 'xs':\n        return 'xs';\n      default:\n        return 'm';\n    }\n  }\n\n  private get isIconButton() {\n    return Boolean(this.icon) && this._iconOnly;\n  }\n\n  private get hasPrefixIcon() {\n    return Boolean(this.icon) && !this._iconOnly && !this.iconSuffix;\n  }\n\n  private get hasSuffixIcon() {\n    return Boolean(this.icon) && !this._iconOnly && this.iconSuffix;\n  }\n\n  private get content() {\n    return [\n      this.hasPrefixIcon ? (\n        <cat-icon icon={this.icon} size={this.iconSize} class=\"cat-button-prefix\" part=\"prefix\"></cat-icon>\n      ) : null,\n      this.isIconButton ? (\n        <cat-icon icon={this.icon} size={this.iconSize}></cat-icon>\n      ) : (\n        <span class=\"cat-button-content\" part=\"content\">\n          <slot></slot>\n        </span>\n      ),\n      this.hasSuffixIcon ? (\n        <cat-icon icon={this.icon} size={this.iconSize} class=\"cat-button-suffix\" part=\"suffix\"></cat-icon>\n      ) : null,\n      this.loading ? <cat-spinner size={this.spinnerSize}></cat-spinner> : null\n    ];\n  }\n\n  private onClick(event: MouseEvent) {\n    this.catClick.emit(event);\n  }\n\n  private onFocus(event: FocusEvent) {\n    this.catFocus.emit(event);\n  }\n\n  private onBlur(event: FocusEvent) {\n    this.catBlur.emit(event);\n  }\n}\n","@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  display: inline-flex;\n  vertical-align: middle;\n  @include cat-select(none);\n}\n\n:host([hidden]) {\n  display: none;\n}\n\nspan {\n  display: inline-flex;\n}\n\nsvg {\n  fill: currentColor;\n  stroke: none;\n  transform-origin: center center;\n  width: 1em;\n  height: 1em;\n}\n\n// ----- size\n\n@mixin size($size) {\n  .cat-icon-#{$size} svg {\n    font-size: cat-size($size) * 0.5;\n  }\n}\n\n@include size('xs');\n@include size('s');\n@include size('m');\n@include size('l');\n@include size('xl');\n","import { Component, h, Prop } from '@stencil/core';\nimport { CatIconRegistry } from './cat-icon-registry';\n\n/**\n * Icons are used to provide additional meaning or in places where text label\n * doesn't fit.\n *\n * @part icon - The native span element wrapping the SVG icon.\n */\n@Component({\n  tag: 'cat-icon',\n  styleUrl: 'cat-icon.scss',\n  shadow: true\n})\nexport class CatIcon {\n  private readonly iconRegistry = CatIconRegistry.getInstance();\n\n  /**\n   * The name of the icon.\n   */\n  @Prop() icon = '';\n\n  /**\n   * The size of the icon.\n   */\n  @Prop() size: 'xs' | 's' | 'm' | 'l' | 'xl' | 'inline' = 'm';\n\n  /**\n   * Adds accessible label for the icon that is only shown for screen\n   * readers. The `aria-hidden` attribute will be set if no label is present.\n   */\n  @Prop({ attribute: 'a11y-label' }) a11yLabel?: string;\n\n  render() {\n    return (\n      <span\n        innerHTML={this.iconRegistry.getIcon(this.icon)}\n        aria-label={this.a11yLabel}\n        aria-hidden={this.a11yLabel ? null : 'true'}\n        part=\"icon\"\n        class={{\n          [`cat-icon-${this.size}`]: this.size !== 'inline'\n        }}\n      ></span>\n    );\n  }\n}\n","function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let _debug_loop_count_ = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _debug_loop_count_++;\n\n      if (_debug_loop_count_ > 100) {\n        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));\n      }\n    }\n\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset) {\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]); // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside of the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    return {\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n\n      if (currentPlacement == null) {\n        return {};\n      }\n\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;\n\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$map$so;\n\n              const placement = (_overflowsData$map$so = overflowsData.map(d => [d, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nfunction convertValueToCoords(placement, rects, value, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value({ ...rects,\n    placement\n  }) : value; // eslint-disable-next-line prefer-const\n\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const diffCoords = convertValueToCoords(placement, rects, value, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        height: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        width: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      const prevDimensions = await platform.getDimensions(elements.floating);\n      apply == null ? void 0 : apply({ ...dimensions,\n        ...rects\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n\n      if (prevDimensions.width !== nextDimensions.width || prevDimensions.height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return (value == null ? void 0 : value.toString()) === '[object Window]';\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(navigator.userAgent); // Feature detection for this fails in various ways\n  //  Always-visible scrollbar or not\n  //  Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? win.visualViewport.offsetLeft : 0)) / scaleX;\n  const y = (clientRect.top + (addVisualOffsets ? win.visualViewport.offsetTop : 0)) / scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isWindow(element)) {\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent), strategy === 'fixed');\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n\n  if (['html', 'body', '#document'].includes(getNodeName(parentNode))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n\n  return getNearestOverflowAncestor(parentNode);\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(getParentNode(target)));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(element);\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize: _elementResize = true,\n    animationFrame = false\n  } = options;\n  let cleanedUp = false;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const elementResize = _elementResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    observer = new ResizeObserver(update);\n    isElement(reference) && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    if (cleanedUp) {\n      return;\n    }\n\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  return () => {\n    var _observer;\n\n    cleanedUp = true;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n","/*!\n* tabbable 5.3.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  return element.getRootNode();\n} : function (element) {\n  return element.ownerDocument;\n};\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @typedef {Object} CandidatesScope\n * @property {Element} scope contains inner candidates\n * @property {Element[]} candidates\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidatesScope into the returned list\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidatesScope>}\n */\n\n\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scope: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      } // iterate over shadow content if possible\n\n\n      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      if (shadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scope: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n\n  return candidates;\n};\n\nvar getTabindex = function getTabindex(node, isScope) {\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    //\n    // isScope is positive for custom element with shadow root or slot that by default\n    // have tabIndex -1, but need to be sorted by document order in order for their\n    // content to be inserted in the correct position\n    if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute('tabindex'), 10))) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || getRootNode(node);\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n      width = _node$getBoundingClie.width,\n      height = _node$getBoundingClie.height;\n\n  return width === 0 && height === 0;\n};\n\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n      getShadowRoot = _ref.getShadowRoot;\n\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n    // didn't find it sitting in an undisclosed shadow (or shadows are disabled) so now we\n    //  can just test to see if it would normally be visible or not\n    // this works wherever the node is: if there's at least one client rect, it's\n    //  somehow displayed; it also covers the CSS 'display: contents' case where the\n    //  node itself is hidden in place of its contents; and there's no need to search\n    //  up the hierarchy either\n\n\n    return !node.getClientRects().length;\n  } else if (displayCheck === 'non-zero-area') {\n    return isZeroArea(node);\n  }\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i); // when the first <legend> (in document order) is found\n\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        } // the disabled <fieldset> containing `node` has no <legend>\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * @param {Array.<Element|CandidatesScope>} candidates\n * @returns Element[]\n */\n\n\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scope;\n    var element = isScope ? item.scope : item;\n    var candidateTabindex = getTabindex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n\n  return sortByOrder(candidates);\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates;\n\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([el], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 6.8.1\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, isFocusable } from 'tabbable';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar activeFocusTraps = function () {\n  var trapQueue = [];\n  return {\n    activateTrap: function activateTrap(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n    deactivateTrap: function deactivateTrap(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n}();\n\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\n\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n};\n\nvar isTabEvent = function isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n};\n\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n}; // Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\n\n\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n  return idx;\n};\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\n\n\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\n\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true\n  }, userOptions);\n\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   firstTabbableNode: HTMLElement|null,\n    //   lastTabbableNode: HTMLElement|null,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n\n\n  var findContainerIndex = function findContainerIndex(element) {\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n          tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n\n\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n\n      optionValue = optionValue.apply(void 0, params);\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      } // else, empty string (invalid), null (invalid), 0 (invalid)\n\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n\n    return node;\n  };\n\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus'); // false explicitly indicates we want no initialFocus at all\n\n    if (node === false) {\n      return false;\n    }\n\n    if (node === undefined) {\n      // option not specified: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode; // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n\n    return node;\n  };\n\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions); // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes\n\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,\n        lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,\n\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          // NOTE: If tabindex is positive (in order to manipulate the tab order separate\n          //  from the DOM order), this __will not work__ because the list of focusableNodes,\n          //  while it contains tabbable nodes, does not sort its nodes in any order other\n          //  than DOM order, because it can't: Where would you place focusable (but not\n          //  tabbable) nodes in that order? They have no order, because they aren't tabbale...\n          // Support for positive tabindex is already broken and hard to manage (possibly\n          //  not supportable, TBD), so this isn't going to make things worse than they\n          //  already are, and at least makes things better for the majority of cases where\n          //  tabindex is either 0/unset or negative.\n          // FYI, positive tabindex issue: https://github.com/focus-trap/focus-trap/issues/375\n          var nodeIdx = focusableNodes.findIndex(function (n) {\n            return n === node;\n          });\n\n          if (nodeIdx < 0) {\n            return undefined;\n          }\n\n          if (forward) {\n            return focusableNodes.slice(nodeIdx + 1).find(function (n) {\n              return isTabbable(n, config.tabbableOptions);\n            });\n          }\n\n          return focusableNodes.slice(0, nodeIdx).reverse().find(function (n) {\n            return isTabbable(n, config.tabbableOptions);\n          });\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    }); // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n  };\n\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n\n    if (node === doc.activeElement) {\n      return;\n    }\n\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    state.mostRecentlyFocusedNode = node;\n\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  }; // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n\n\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // if, on deactivation, we should return focus to the node originally-focused\n        //  when the trap was activated (or the configured `setReturnFocus` node),\n        //  then assume it's also OK to return focus to the outside node that was\n        //  just clicked, causing deactivation, as long as that node is focusable;\n        //  if it isn't focusable, then return focus to the original node focused\n        //  on activation (or the configured `setReturnFocus` node)\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked, whether it's focusable or not; by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node)\n        returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)\n      });\n      return;\n    } // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    } // otherwise, prevent the click\n\n\n    e.preventDefault();\n  }; // In case focus escapes the trap for some strange reason, pull it back in.\n\n\n  var checkFocusIn = function checkFocusIn(e) {\n    var target = getActualTarget(e);\n    var targetContained = findContainerIndex(target) >= 0; // In Firefox when you Tab out of an iframe the Document is briefly focused.\n\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      e.stopImmediatePropagation();\n      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n    }\n  }; // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n\n\n  var checkTab = function checkTab(e) {\n    var target = getActualTarget(e);\n    updateTabbableNodes();\n    var destinationNode = null;\n\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back in to...\n        if (e.shiftKey) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (e.shiftKey) {\n        // REVERSE\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref2) {\n          var firstTabbableNode = _ref2.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = destinationGroup.lastTabbableNode;\n        }\n      } else {\n        // FORWARD\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var lastTabbableNode = _ref3.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = _destinationGroup.firstTabbableNode;\n        }\n      }\n    } else {\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n\n    if (destinationNode) {\n      e.preventDefault();\n      tryFocus(destinationNode);\n    } // else, let the browser take care of [shift+]tab and move the focus\n\n  };\n\n  var checkKey = function checkKey(e) {\n    if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {\n      e.preventDefault();\n      trap.deactivate();\n      return;\n    }\n\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  };\n\n  var checkClick = function checkClick(e) {\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n\n    var target = getActualTarget(e);\n\n    if (findContainerIndex(target) >= 0) {\n      return;\n    }\n\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }; //\n  // EVENT LISTENERS\n  //\n\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    } // There can be only one listening focus trap at a time\n\n\n    activeFocusTraps.activateTrap(trap); // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  }; //\n  // TRAP DEFINITION\n  //\n\n\n  trap = {\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n\n      if (onActivate) {\n        onActivate();\n      }\n\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n\n        addListeners();\n\n        if (onPostActivate) {\n          onPostActivate();\n        }\n      };\n\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      activeFocusTraps.deactivateTrap(trap);\n      var onDeactivate = getOption(deactivateOptions, 'onDeactivate');\n      var onPostDeactivate = getOption(deactivateOptions, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(deactivateOptions, 'checkCanReturnFocus');\n\n      if (onDeactivate) {\n        onDeactivate();\n      }\n\n      var returnFocus = getOption(deactivateOptions, 'returnFocus', 'returnFocusOnDeactivate');\n\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n\n          if (onPostDeactivate) {\n            onPostDeactivate();\n          }\n        });\n      };\n\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause() {\n      if (state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = true;\n      removeListeners();\n      return this;\n    },\n    unpause: function unpause() {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n\n      state.paused = false;\n      updateTabbableNodes();\n      addListeners();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n\n      if (state.active) {\n        updateTabbableNodes();\n      }\n\n      return this;\n    }\n  }; // initialize container elements\n\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","import { FocusableElement, tabbable } from 'tabbable';\n\ntype Container = Element | FocusableElement | null;\n\nconst firstTabbable = (container?: Container): FocusableElement | undefined => {\n  return (container ? tabbable(container, { includeContainer: true, getShadowRoot: true }) : []).shift();\n};\n\nexport default firstTabbable;\n","@import 'variables';\n@import 'mixins';\n\n$-min-width: 8rem;\n$-max-width: 16rem;\n$-min-height: 2rem;\n$-max-height: calc(100vh - 48px);\n\n:host {\n  display: inline-block;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.content {\n  padding-top: $cat-body-margin-bottom * 0.5;\n  padding-bottom: $cat-body-margin-bottom * 0.5;\n  position: absolute;\n  background: cat-token('color.ui.background.body');\n  display: none;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  min-width: $-min-width;\n  max-width: $-max-width;\n  min-height: $-min-height;\n  max-height: $-max-height;\n  @include cat-elevation(1);\n  border-radius: cat-border-radius('m');\n}\n","import { autoUpdate, computePosition, flip, offset, Placement } from '@floating-ui/dom';\nimport { Component, Event, EventEmitter, h, Host, Listen, Prop } from '@stencil/core';\nimport * as focusTrap from 'focus-trap';\nimport { FocusableElement, tabbable } from 'tabbable';\nimport firstTabbable from '../../utils/first-tabbable';\n\nlet nextUniqueId = 0;\n\n@Component({\n  tag: 'cat-menu',\n  styleUrl: 'cat-menu.scss',\n  shadow: true\n})\nexport class CatMenu {\n  private static readonly OFFSET = 4;\n  private readonly id = nextUniqueId++;\n  private triggerSlot?: Element;\n  private trigger?: FocusableElement;\n  private content?: HTMLElement;\n  private trap?: focusTrap.FocusTrap;\n  private keyListener?: (event: KeyboardEvent) => void;\n\n  /**\n   * The placement of the menu.\n   */\n  @Prop() placement: Placement = 'bottom-start';\n\n  /**\n   * Emitted when the menu is opened.\n   */\n  @Event() catOpen!: EventEmitter<FocusEvent>;\n\n  /**\n   * Emitted when the menu is closed.\n   */\n  @Event() catClose!: EventEmitter<FocusEvent>;\n\n  @Listen('catClick')\n  clickHandler(event: CustomEvent<MouseEvent>) {\n    // hide menu on button click\n    if (this.content && event.composedPath().includes(this.content)) {\n      this.trap?.deactivate();\n      this.hide();\n    }\n  }\n\n  componentDidLoad(): void {\n    this.trigger = firstTabbable(this.triggerSlot);\n    this.trigger?.setAttribute('aria-haspopup', 'true');\n    this.trigger?.setAttribute('aria-expanded', 'false');\n    this.trigger?.setAttribute('aria-controls', this.contentId);\n    this.content?.setAttribute('id', this.contentId);\n    if (this.trigger && this.content) {\n      this.trigger?.addEventListener('click', () => this.show());\n      autoUpdate(this.trigger, this.content, () => this.update());\n    }\n\n    this.keyListener = event => {\n      if (this.content && ['ArrowDown', 'ArrowUp'].includes(event.key)) {\n        const targetElements = tabbable(this.content, { includeContainer: false, getShadowRoot: true });\n        const activeElement = firstTabbable(document.activeElement);\n        const activeIdx = activeElement ? targetElements.indexOf(activeElement) : -1;\n        const activeOff = event.key === 'ArrowDown' ? 1 : -1;\n        const targetIdx = activeIdx < 0 ? 0 : (activeIdx + activeOff + targetElements.length) % targetElements.length;\n        targetElements[targetIdx].focus();\n        event.preventDefault();\n      }\n    };\n    document.addEventListener('keydown', this.keyListener);\n  }\n\n  disconnectedCallback(): void {\n    if (this.keyListener) {\n      document.removeEventListener('keydown', this.keyListener);\n    }\n  }\n\n  render() {\n    return (\n      <Host>\n        <slot name=\"trigger\" ref={el => (this.triggerSlot = el)}></slot>\n        <div class=\"content\" ref={el => (this.content = el)}>\n          <slot name=\"content\"></slot>\n        </div>\n      </Host>\n    );\n  }\n\n  private get contentId() {\n    return `cat-menu-${this.id}`;\n  }\n\n  private show() {\n    if (this.content) {\n      this.content.style.display = 'block';\n      this.trigger?.setAttribute('aria-expanded', 'true');\n      this.catOpen.emit();\n      this.trap = this.trap\n        ? this.trap.updateContainerElements(this.content)\n        : focusTrap.createFocusTrap(this.content, {\n            tabbableOptions: {\n              getShadowRoot: true\n            },\n            allowOutsideClick: true,\n            clickOutsideDeactivates: event => !this.content || !event.composedPath().includes(this.content),\n            onPostDeactivate: () => this.hide()\n          });\n      this.trap.activate();\n    }\n  }\n\n  private hide() {\n    if (this.content) {\n      this.content.style.display = '';\n      this.trigger?.setAttribute('aria-expanded', 'false');\n      this.catClose.emit();\n    }\n  }\n\n  private update() {\n    if (this.trigger && this.content) {\n      computePosition(this.trigger, this.content, {\n        placement: this.placement,\n        middleware: [offset(CatMenu.OFFSET), flip()]\n      }).then(({ x, y }) => {\n        if (this.content) {\n          Object.assign(this.content.style, {\n            left: `${x}px`,\n            top: `${y}px`\n          });\n        }\n      });\n    }\n  }\n}\n","export function isFunction(value) {\n    return typeof value === 'function';\n}\n//# sourceMappingURL=isFunction.js.map","export function createErrorClass(createImpl) {\n    const _super = (instance) => {\n        Error.call(instance);\n        instance.stack = new Error().stack;\n    };\n    const ctorFunc = createImpl(_super);\n    ctorFunc.prototype = Object.create(Error.prototype);\n    ctorFunc.prototype.constructor = ctorFunc;\n    return ctorFunc;\n}\n//# sourceMappingURL=createErrorClass.js.map","import { createErrorClass } from './createErrorClass';\nexport const UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {\n    _super(this);\n    this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n});\n//# sourceMappingURL=UnsubscriptionError.js.map","export function arrRemove(arr, item) {\n    if (arr) {\n        const index = arr.indexOf(item);\n        0 <= index && arr.splice(index, 1);\n    }\n}\n//# sourceMappingURL=arrRemove.js.map","import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { arrRemove } from './util/arrRemove';\nexport class Subscription {\n    constructor(initialTeardown) {\n        this.initialTeardown = initialTeardown;\n        this.closed = false;\n        this._parentage = null;\n        this._finalizers = null;\n    }\n    unsubscribe() {\n        let errors;\n        if (!this.closed) {\n            this.closed = true;\n            const { _parentage } = this;\n            if (_parentage) {\n                this._parentage = null;\n                if (Array.isArray(_parentage)) {\n                    for (const parent of _parentage) {\n                        parent.remove(this);\n                    }\n                }\n                else {\n                    _parentage.remove(this);\n                }\n            }\n            const { initialTeardown: initialFinalizer } = this;\n            if (isFunction(initialFinalizer)) {\n                try {\n                    initialFinalizer();\n                }\n                catch (e) {\n                    errors = e instanceof UnsubscriptionError ? e.errors : [e];\n                }\n            }\n            const { _finalizers } = this;\n            if (_finalizers) {\n                this._finalizers = null;\n                for (const finalizer of _finalizers) {\n                    try {\n                        execFinalizer(finalizer);\n                    }\n                    catch (err) {\n                        errors = errors !== null && errors !== void 0 ? errors : [];\n                        if (err instanceof UnsubscriptionError) {\n                            errors = [...errors, ...err.errors];\n                        }\n                        else {\n                            errors.push(err);\n                        }\n                    }\n                }\n            }\n            if (errors) {\n                throw new UnsubscriptionError(errors);\n            }\n        }\n    }\n    add(teardown) {\n        var _a;\n        if (teardown && teardown !== this) {\n            if (this.closed) {\n                execFinalizer(teardown);\n            }\n            else {\n                if (teardown instanceof Subscription) {\n                    if (teardown.closed || teardown._hasParent(this)) {\n                        return;\n                    }\n                    teardown._addParent(this);\n                }\n                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n            }\n        }\n    }\n    _hasParent(parent) {\n        const { _parentage } = this;\n        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n    }\n    _addParent(parent) {\n        const { _parentage } = this;\n        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n    }\n    _removeParent(parent) {\n        const { _parentage } = this;\n        if (_parentage === parent) {\n            this._parentage = null;\n        }\n        else if (Array.isArray(_parentage)) {\n            arrRemove(_parentage, parent);\n        }\n    }\n    remove(teardown) {\n        const { _finalizers } = this;\n        _finalizers && arrRemove(_finalizers, teardown);\n        if (teardown instanceof Subscription) {\n            teardown._removeParent(this);\n        }\n    }\n}\nSubscription.EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n})();\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nexport function isSubscription(value) {\n    return (value instanceof Subscription ||\n        (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe)));\n}\nfunction execFinalizer(finalizer) {\n    if (isFunction(finalizer)) {\n        finalizer();\n    }\n    else {\n        finalizer.unsubscribe();\n    }\n}\n//# sourceMappingURL=Subscription.js.map","export const config = {\n    onUnhandledError: null,\n    onStoppedNotification: null,\n    Promise: undefined,\n    useDeprecatedSynchronousErrorHandling: false,\n    useDeprecatedNextContext: false,\n};\n//# sourceMappingURL=config.js.map","export const timeoutProvider = {\n    setTimeout(handler, timeout, ...args) {\n        const { delegate } = timeoutProvider;\n        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n            return delegate.setTimeout(handler, timeout, ...args);\n        }\n        return setTimeout(handler, timeout, ...args);\n    },\n    clearTimeout(handle) {\n        const { delegate } = timeoutProvider;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=timeoutProvider.js.map","import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\nexport function reportUnhandledError(err) {\n    timeoutProvider.setTimeout(() => {\n        const { onUnhandledError } = config;\n        if (onUnhandledError) {\n            onUnhandledError(err);\n        }\n        else {\n            throw err;\n        }\n    });\n}\n//# sourceMappingURL=reportUnhandledError.js.map","export function noop() { }\n//# sourceMappingURL=noop.js.map","export const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();\nexport function errorNotification(error) {\n    return createNotification('E', undefined, error);\n}\nexport function nextNotification(value) {\n    return createNotification('N', value, undefined);\n}\nexport function createNotification(kind, value, error) {\n    return {\n        kind,\n        value,\n        error,\n    };\n}\n//# sourceMappingURL=NotificationFactories.js.map","import { config } from '../config';\nlet context = null;\nexport function errorContext(cb) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        const isRoot = !context;\n        if (isRoot) {\n            context = { errorThrown: false, error: null };\n        }\n        cb();\n        if (isRoot) {\n            const { errorThrown, error } = context;\n            context = null;\n            if (errorThrown) {\n                throw error;\n            }\n        }\n    }\n    else {\n        cb();\n    }\n}\nexport function captureError(err) {\n    if (config.useDeprecatedSynchronousErrorHandling && context) {\n        context.errorThrown = true;\n        context.error = err;\n    }\n}\n//# sourceMappingURL=errorContext.js.map","import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n    constructor(destination) {\n        super();\n        this.isStopped = false;\n        if (destination) {\n            this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(this);\n            }\n        }\n        else {\n            this.destination = EMPTY_OBSERVER;\n        }\n    }\n    static create(next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    }\n    next(value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    }\n    error(err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    complete() {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.isStopped = true;\n            super.unsubscribe();\n            this.destination = null;\n        }\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n    _complete() {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n}\nconst _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nclass ConsumerObserver {\n    constructor(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    next(value) {\n        const { partialObserver } = this;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n    error(err) {\n        const { partialObserver } = this;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    }\n    complete() {\n        const { partialObserver } = this;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n}\nexport class SafeSubscriber extends Subscriber {\n    constructor(observerOrNext, error, complete) {\n        super();\n        let partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            let context;\n            if (this && config.useDeprecatedNextContext) {\n                context = Object.create(observerOrNext);\n                context.unsubscribe = () => this.unsubscribe();\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context),\n                    error: observerOrNext.error && bind(observerOrNext.error, context),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        this.destination = new ConsumerObserver(partialObserver);\n    }\n}\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    const { onStoppedNotification } = config;\n    onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n//# sourceMappingURL=Subscriber.js.map","export const observable = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n//# sourceMappingURL=observable.js.map","export function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map","import { identity } from './identity';\nexport function pipe(...fns) {\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn) => fn(prev), input);\n    };\n}\n//# sourceMappingURL=pipe.js.map","import { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription } from './Subscription';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\nexport class Observable {\n    constructor(subscribe) {\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    lift(operator) {\n        const observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    }\n    subscribe(observerOrNext, error, complete) {\n        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n        errorContext(() => {\n            const { operator, source } = this;\n            subscriber.add(operator\n                ?\n                    operator.call(subscriber, source)\n                : source\n                    ?\n                        this._subscribe(subscriber)\n                    :\n                        this._trySubscribe(subscriber));\n        });\n        return subscriber;\n    }\n    _trySubscribe(sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            sink.error(err);\n        }\n    }\n    forEach(next, promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            const subscriber = new SafeSubscriber({\n                next: (value) => {\n                    try {\n                        next(value);\n                    }\n                    catch (err) {\n                        reject(err);\n                        subscriber.unsubscribe();\n                    }\n                },\n                error: reject,\n                complete: resolve,\n            });\n            this.subscribe(subscriber);\n        });\n    }\n    _subscribe(subscriber) {\n        var _a;\n        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n    }\n    [Symbol_observable]() {\n        return this;\n    }\n    pipe(...operations) {\n        return pipeFromArray(operations)(this);\n    }\n    toPromise(promiseCtor) {\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor((resolve, reject) => {\n            let value;\n            this.subscribe((x) => (value = x), (err) => reject(err), () => resolve(value));\n        });\n    }\n}\nObservable.create = (subscribe) => {\n    return new Observable(subscribe);\n};\nfunction getPromiseCtor(promiseCtor) {\n    var _a;\n    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n    return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n//# sourceMappingURL=Observable.js.map","import { isFunction } from './isFunction';\nexport function hasLift(source) {\n    return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nexport function operate(init) {\n    return (source) => {\n        if (hasLift(source)) {\n            return source.lift(function (liftedSource) {\n                try {\n                    return init(liftedSource, this);\n                }\n                catch (err) {\n                    this.error(err);\n                }\n            });\n        }\n        throw new TypeError('Unable to lift unknown Observable type');\n    };\n}\n//# sourceMappingURL=lift.js.map","import { Subscriber } from '../Subscriber';\nexport function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nexport class OperatorSubscriber extends Subscriber {\n    constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n        super(destination);\n        this.onFinalize = onFinalize;\n        this.shouldUnsubscribe = shouldUnsubscribe;\n        this._next = onNext\n            ? function (value) {\n                try {\n                    onNext(value);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n            }\n            : super._next;\n        this._error = onError\n            ? function (err) {\n                try {\n                    onError(err);\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._error;\n        this._complete = onComplete\n            ? function () {\n                try {\n                    onComplete();\n                }\n                catch (err) {\n                    destination.error(err);\n                }\n                finally {\n                    this.unsubscribe();\n                }\n            }\n            : super._complete;\n    }\n    unsubscribe() {\n        var _a;\n        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n            const { closed } = this;\n            super.unsubscribe();\n            !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n        }\n    }\n}\n//# sourceMappingURL=OperatorSubscriber.js.map","import { createErrorClass } from './createErrorClass';\nexport const ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {\n    _super(this);\n    this.name = 'ObjectUnsubscribedError';\n    this.message = 'object unsubscribed';\n});\n//# sourceMappingURL=ObjectUnsubscribedError.js.map","import { Observable } from './Observable';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\nexport class Subject extends Observable {\n    constructor() {\n        super();\n        this.closed = false;\n        this.currentObservers = null;\n        this.observers = [];\n        this.isStopped = false;\n        this.hasError = false;\n        this.thrownError = null;\n    }\n    lift(operator) {\n        const subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    }\n    _throwIfClosed() {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n    }\n    next(value) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                if (!this.currentObservers) {\n                    this.currentObservers = Array.from(this.observers);\n                }\n                for (const observer of this.currentObservers) {\n                    observer.next(value);\n                }\n            }\n        });\n    }\n    error(err) {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.hasError = this.isStopped = true;\n                this.thrownError = err;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().error(err);\n                }\n            }\n        });\n    }\n    complete() {\n        errorContext(() => {\n            this._throwIfClosed();\n            if (!this.isStopped) {\n                this.isStopped = true;\n                const { observers } = this;\n                while (observers.length) {\n                    observers.shift().complete();\n                }\n            }\n        });\n    }\n    unsubscribe() {\n        this.isStopped = this.closed = true;\n        this.observers = this.currentObservers = null;\n    }\n    get observed() {\n        var _a;\n        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n    }\n    _trySubscribe(subscriber) {\n        this._throwIfClosed();\n        return super._trySubscribe(subscriber);\n    }\n    _subscribe(subscriber) {\n        this._throwIfClosed();\n        this._checkFinalizedStatuses(subscriber);\n        return this._innerSubscribe(subscriber);\n    }\n    _innerSubscribe(subscriber) {\n        const { hasError, isStopped, observers } = this;\n        if (hasError || isStopped) {\n            return EMPTY_SUBSCRIPTION;\n        }\n        this.currentObservers = null;\n        observers.push(subscriber);\n        return new Subscription(() => {\n            this.currentObservers = null;\n            arrRemove(observers, subscriber);\n        });\n    }\n    _checkFinalizedStatuses(subscriber) {\n        const { hasError, thrownError, isStopped } = this;\n        if (hasError) {\n            subscriber.error(thrownError);\n        }\n        else if (isStopped) {\n            subscriber.complete();\n        }\n    }\n    asObservable() {\n        const observable = new Observable();\n        observable.source = this;\n        return observable;\n    }\n}\nSubject.create = (destination, source) => {\n    return new AnonymousSubject(destination, source);\n};\nexport class AnonymousSubject extends Subject {\n    constructor(destination, source) {\n        super();\n        this.destination = destination;\n        this.source = source;\n    }\n    next(value) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    }\n    error(err) {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n    }\n    complete() {\n        var _a, _b;\n        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    _subscribe(subscriber) {\n        var _a, _b;\n        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n    }\n}\n//# sourceMappingURL=Subject.js.map","import { Observable } from '../Observable';\nexport const EMPTY = new Observable((subscriber) => subscriber.complete());\nexport function empty(scheduler) {\n    return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\nfunction emptyScheduled(scheduler) {\n    return new Observable((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n//# sourceMappingURL=empty.js.map","import { isFunction } from './isFunction';\nexport function isScheduler(value) {\n    return value && isFunction(value.schedule);\n}\n//# sourceMappingURL=isScheduler.js.map","import { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexport function popResultSelector(args) {\n    return isFunction(last(args)) ? args.pop() : undefined;\n}\nexport function popScheduler(args) {\n    return isScheduler(last(args)) ? args.pop() : undefined;\n}\nexport function popNumber(args, defaultValue) {\n    return typeof last(args) === 'number' ? args.pop() : defaultValue;\n}\n//# sourceMappingURL=args.js.map","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","export const isArrayLike = ((x) => x && typeof x.length === 'number' && typeof x !== 'function');\n//# sourceMappingURL=isArrayLike.js.map","import { isFunction } from \"./isFunction\";\nexport function isPromise(value) {\n    return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n//# sourceMappingURL=isPromise.js.map","import { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\nexport function isInteropObservable(input) {\n    return isFunction(input[Symbol_observable]);\n}\n//# sourceMappingURL=isInteropObservable.js.map","import { isFunction } from './isFunction';\nexport function isAsyncIterable(obj) {\n    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n//# sourceMappingURL=isAsyncIterable.js.map","export function createInvalidObservableTypeError(input) {\n    return new TypeError(`You provided ${input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);\n}\n//# sourceMappingURL=throwUnobservableError.js.map","export function getSymbolIterator() {\n    if (typeof Symbol !== 'function' || !Symbol.iterator) {\n        return '@@iterator';\n    }\n    return Symbol.iterator;\n}\nexport const iterator = getSymbolIterator();\n//# sourceMappingURL=iterator.js.map","import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\nexport function isIterable(input) {\n    return isFunction(input === null || input === void 0 ? void 0 : input[Symbol_iterator]);\n}\n//# sourceMappingURL=isIterable.js.map","import { __asyncGenerator, __await } from \"tslib\";\nimport { isFunction } from './isFunction';\nexport function readableStreamLikeToAsyncGenerator(readableStream) {\n    return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {\n        const reader = readableStream.getReader();\n        try {\n            while (true) {\n                const { value, done } = yield __await(reader.read());\n                if (done) {\n                    return yield __await(void 0);\n                }\n                yield yield __await(value);\n            }\n        }\n        finally {\n            reader.releaseLock();\n        }\n    });\n}\nexport function isReadableStreamLike(obj) {\n    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n//# sourceMappingURL=isReadableStreamLike.js.map","import { __asyncValues, __awaiter } from \"tslib\";\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\nexport function innerFrom(input) {\n    if (input instanceof Observable) {\n        return input;\n    }\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return fromInteropObservable(input);\n        }\n        if (isArrayLike(input)) {\n            return fromArrayLike(input);\n        }\n        if (isPromise(input)) {\n            return fromPromise(input);\n        }\n        if (isAsyncIterable(input)) {\n            return fromAsyncIterable(input);\n        }\n        if (isIterable(input)) {\n            return fromIterable(input);\n        }\n        if (isReadableStreamLike(input)) {\n            return fromReadableStreamLike(input);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\nexport function fromInteropObservable(obj) {\n    return new Observable((subscriber) => {\n        const obs = obj[Symbol_observable]();\n        if (isFunction(obs.subscribe)) {\n            return obs.subscribe(subscriber);\n        }\n        throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    });\n}\nexport function fromArrayLike(array) {\n    return new Observable((subscriber) => {\n        for (let i = 0; i < array.length && !subscriber.closed; i++) {\n            subscriber.next(array[i]);\n        }\n        subscriber.complete();\n    });\n}\nexport function fromPromise(promise) {\n    return new Observable((subscriber) => {\n        promise\n            .then((value) => {\n            if (!subscriber.closed) {\n                subscriber.next(value);\n                subscriber.complete();\n            }\n        }, (err) => subscriber.error(err))\n            .then(null, reportUnhandledError);\n    });\n}\nexport function fromIterable(iterable) {\n    return new Observable((subscriber) => {\n        for (const value of iterable) {\n            subscriber.next(value);\n            if (subscriber.closed) {\n                return;\n            }\n        }\n        subscriber.complete();\n    });\n}\nexport function fromAsyncIterable(asyncIterable) {\n    return new Observable((subscriber) => {\n        process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n    });\n}\nexport function fromReadableStreamLike(readableStream) {\n    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n    var asyncIterable_1, asyncIterable_1_1;\n    var e_1, _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done;) {\n                const value = asyncIterable_1_1.value;\n                subscriber.next(value);\n                if (subscriber.closed) {\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        subscriber.complete();\n    });\n}\n//# sourceMappingURL=innerFrom.js.map","export function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {\n    const scheduleSubscription = scheduler.schedule(function () {\n        work();\n        if (repeat) {\n            parentSubscription.add(this.schedule(null, delay));\n        }\n        else {\n            this.unsubscribe();\n        }\n    }, delay);\n    parentSubscription.add(scheduleSubscription);\n    if (!repeat) {\n        return scheduleSubscription;\n    }\n}\n//# sourceMappingURL=executeSchedule.js.map","import { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function observeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));\n    });\n}\n//# sourceMappingURL=observeOn.js.map","import { operate } from '../util/lift';\nexport function subscribeOn(scheduler, delay = 0) {\n    return operate((source, subscriber) => {\n        subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n    });\n}\n//# sourceMappingURL=subscribeOn.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function scheduleObservable(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n//# sourceMappingURL=scheduleObservable.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nexport function schedulePromise(input, scheduler) {\n    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n//# sourceMappingURL=schedulePromise.js.map","import { Observable } from '../Observable';\nexport function scheduleArray(input, scheduler) {\n    return new Observable((subscriber) => {\n        let i = 0;\n        return scheduler.schedule(function () {\n            if (i === input.length) {\n                subscriber.complete();\n            }\n            else {\n                subscriber.next(input[i++]);\n                if (!subscriber.closed) {\n                    this.schedule();\n                }\n            }\n        });\n    });\n}\n//# sourceMappingURL=scheduleArray.js.map","import { Observable } from '../Observable';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleIterable(input, scheduler) {\n    return new Observable((subscriber) => {\n        let iterator;\n        executeSchedule(subscriber, scheduler, () => {\n            iterator = input[Symbol_iterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                let value;\n                let done;\n                try {\n                    ({ value, done } = iterator.next());\n                }\n                catch (err) {\n                    subscriber.error(err);\n                    return;\n                }\n                if (done) {\n                    subscriber.complete();\n                }\n                else {\n                    subscriber.next(value);\n                }\n            }, 0, true);\n        });\n        return () => isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();\n    });\n}\n//# sourceMappingURL=scheduleIterable.js.map","import { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\nexport function scheduleAsyncIterable(input, scheduler) {\n    if (!input) {\n        throw new Error('Iterable cannot be null');\n    }\n    return new Observable((subscriber) => {\n        executeSchedule(subscriber, scheduler, () => {\n            const iterator = input[Symbol.asyncIterator]();\n            executeSchedule(subscriber, scheduler, () => {\n                iterator.next().then((result) => {\n                    if (result.done) {\n                        subscriber.complete();\n                    }\n                    else {\n                        subscriber.next(result.value);\n                    }\n                });\n            }, 0, true);\n        });\n    });\n}\n//# sourceMappingURL=scheduleAsyncIterable.js.map","import { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nexport function scheduleReadableStreamLike(input, scheduler) {\n    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n//# sourceMappingURL=scheduleReadableStreamLike.js.map","import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\nexport function scheduled(input, scheduler) {\n    if (input != null) {\n        if (isInteropObservable(input)) {\n            return scheduleObservable(input, scheduler);\n        }\n        if (isArrayLike(input)) {\n            return scheduleArray(input, scheduler);\n        }\n        if (isPromise(input)) {\n            return schedulePromise(input, scheduler);\n        }\n        if (isAsyncIterable(input)) {\n            return scheduleAsyncIterable(input, scheduler);\n        }\n        if (isIterable(input)) {\n            return scheduleIterable(input, scheduler);\n        }\n        if (isReadableStreamLike(input)) {\n            return scheduleReadableStreamLike(input, scheduler);\n        }\n    }\n    throw createInvalidObservableTypeError(input);\n}\n//# sourceMappingURL=scheduled.js.map","import { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\nexport function from(input, scheduler) {\n    return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n//# sourceMappingURL=from.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function map(project, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            subscriber.next(project.call(thisArg, value, index++));\n        }));\n    });\n}\n//# sourceMappingURL=map.js.map","import { map } from \"../operators/map\";\nconst { isArray } = Array;\nfunction callOrApply(fn, args) {\n    return isArray(args) ? fn(...args) : fn(args);\n}\nexport function mapOneOrManyArgs(fn) {\n    return map(args => callOrApply(fn, args));\n}\n//# sourceMappingURL=mapOneOrManyArgs.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n    const buffer = [];\n    let active = 0;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => {\n        if (isComplete && !buffer.length && !active) {\n            subscriber.complete();\n        }\n    };\n    const outerNext = (value) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n    const doInnerSub = (value) => {\n        expand && subscriber.next(value);\n        active++;\n        let innerComplete = false;\n        innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n            if (expand) {\n                outerNext(innerValue);\n            }\n            else {\n                subscriber.next(innerValue);\n            }\n        }, () => {\n            innerComplete = true;\n        }, undefined, () => {\n            if (innerComplete) {\n                try {\n                    active--;\n                    while (buffer.length && active < concurrent) {\n                        const bufferedValue = buffer.shift();\n                        if (innerSubScheduler) {\n                            executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                        }\n                        else {\n                            doInnerSub(bufferedValue);\n                        }\n                    }\n                    checkComplete();\n                }\n                catch (err) {\n                    subscriber.error(err);\n                }\n            }\n        }));\n    };\n    source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n        isComplete = true;\n        checkComplete();\n    }));\n    return () => {\n        additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n    };\n}\n//# sourceMappingURL=mergeInternals.js.map","import { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\nexport function mergeMap(project, resultSelector, concurrent = Infinity) {\n    if (isFunction(resultSelector)) {\n        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n    }\n    else if (typeof resultSelector === 'number') {\n        concurrent = resultSelector;\n    }\n    return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n//# sourceMappingURL=mergeMap.js.map","import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nexport function mergeAll(concurrent = Infinity) {\n    return mergeMap(identity, concurrent);\n}\n//# sourceMappingURL=mergeAll.js.map","import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'];\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'];\nconst jqueryMethods = ['on', 'off'];\nexport function fromEvent(target, eventName, options, resultSelector) {\n    if (isFunction(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));\n    }\n    const [add, remove] = isEventTarget(target)\n        ? eventTargetMethods.map((methodName) => (handler) => target[methodName](eventName, handler, options))\n        :\n            isNodeStyleEventEmitter(target)\n                ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n                : isJQueryStyleEventEmitter(target)\n                    ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n                    : [];\n    if (!add) {\n        if (isArrayLike(target)) {\n            return mergeMap((subTarget) => fromEvent(subTarget, eventName, options))(innerFrom(target));\n        }\n    }\n    if (!add) {\n        throw new TypeError('Invalid event target');\n    }\n    return new Observable((subscriber) => {\n        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);\n        add(handler);\n        return () => remove(handler);\n    });\n}\nfunction toCommonHandlerRegistry(target, eventName) {\n    return (methodName) => (handler) => target[methodName](eventName, handler);\n}\nfunction isNodeStyleEventEmitter(target) {\n    return isFunction(target.addListener) && isFunction(target.removeListener);\n}\nfunction isJQueryStyleEventEmitter(target) {\n    return isFunction(target.on) && isFunction(target.off);\n}\nfunction isEventTarget(target) {\n    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n//# sourceMappingURL=fromEvent.js.map","import { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\nexport function merge(...args) {\n    const scheduler = popScheduler(args);\n    const concurrent = popNumber(args, Infinity);\n    const sources = args;\n    return !sources.length\n        ?\n            EMPTY\n        : sources.length === 1\n            ?\n                innerFrom(sources[0])\n            :\n                mergeAll(concurrent)(from(sources, scheduler));\n}\n//# sourceMappingURL=merge.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function filter(predicate, thisArg) {\n    return operate((source, subscriber) => {\n        let index = 0;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n    });\n}\n//# sourceMappingURL=filter.js.map","import { identity } from '../util/identity';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nexport function distinctUntilChanged(comparator, keySelector = identity) {\n    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;\n    return operate((source, subscriber) => {\n        let previousKey;\n        let first = true;\n        source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            const currentKey = keySelector(value);\n            if (first || !comparator(previousKey, currentKey)) {\n                first = false;\n                previousKey = currentKey;\n                subscriber.next(value);\n            }\n        }));\n    });\n}\nfunction defaultCompare(a, b) {\n    return a === b;\n}\n//# sourceMappingURL=distinctUntilChanged.js.map","import { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\nexport function takeUntil(notifier) {\n    return operate((source, subscriber) => {\n        innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n        !subscriber.closed && source.subscribe(subscriber);\n    });\n}\n//# sourceMappingURL=takeUntil.js.map","@import 'variables';\n\n:host {\n  overflow: hidden;\n  position: relative;\n  display: flex;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n// ----- Scroll shadows\n\n%shadow {\n  position: absolute;\n  transition: $cat-scrollable-shadow-transition;\n}\n\n.shadow-top {\n  @extend %shadow;\n  z-index: 2;\n  width: 100%;\n  top: 0;\n}\n\n.shadow-left {\n  @extend %shadow;\n  z-index: 4;\n  height: 100%;\n  left: 0;\n}\n\n.shadow-right {\n  @extend %shadow;\n  z-index: 4;\n  height: 100%;\n  right: 0;\n}\n\n.shadow-bottom {\n  @extend %shadow;\n  z-index: 2;\n  width: 100%;\n  bottom: 0;\n}\n\n// ----- Component\n\n.scrollable-wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  pointer-events: none;\n\n  &.cat-scrollable-top .shadow-top,\n  &.cat-scrollable-bottom .shadow-bottom,\n  &.cat-scrollable-left .shadow-left,\n  &.cat-scrollable-right .shadow-right {\n    box-shadow: $cat-scrollable-shadow;\n  }\n}\n\n.scrollable-content {\n  overflow: hidden;\n  white-space: nowrap;\n\n  &.scroll-x {\n    overflow-x: auto;\n  }\n\n  &.scroll-y {\n    overflow-y: auto;\n  }\n\n  &.no-overscroll {\n    overscroll-behavior: contain;\n  }\n}\n","import { Component, Element, Event, EventEmitter, h, Prop } from '@stencil/core';\nimport { fromEvent, merge, Observable, Subject } from 'rxjs';\nimport { distinctUntilChanged, filter, map, takeUntil } from 'rxjs/operators';\n\n@Component({\n  tag: 'cat-scrollable',\n  styleUrl: 'cat-scrollable.scss',\n  shadow: true\n})\nexport class CatScrollable {\n  scrollElement?: HTMLElement;\n  scrollWrapperElement?: HTMLElement;\n  private readonly init = new Subject<void>();\n  private readonly destroyed = new Subject<void>();\n  private scrolled!: Observable<Event>;\n\n  @Element() el!: HTMLElement;\n\n  /** Flags to enable/disable scroll shadowX. */\n  @Prop()\n  shadowX = true;\n\n  /** Flags to enable/disable scroll shadowY. */\n  @Prop()\n  shadowY = true;\n\n  /** Flags to enable/disable overflowX. */\n  @Prop()\n  overflowX = true;\n\n  /** Flags to enable/disable overflowY. */\n  @Prop()\n  overflowY = true;\n\n  /** Flag to enable/disable overscroll behavior. */\n  @Prop()\n  overscroll = true;\n\n  /**\n   * Flag to fire an initial event after content initialization.\n   */\n  @Prop() scrolledInit = true;\n\n  /**\n   * Buffer to be used to calculate the scroll distance.\n   */\n  @Prop()\n  scrolledBuffer = 0;\n\n  /**\n   * Emitted when the content is fully scrolled to the top.\n   */\n  @Event() scrolledTop!: EventEmitter<void>;\n\n  /**\n   * Emitted when the content is fully scrolled to the left.\n   */\n  @Event() scrolledLeft!: EventEmitter<void>;\n\n  /**\n   * Emitted when the content is fully scrolled to the right.\n   */\n  @Event() scrolledRight!: EventEmitter<void>;\n\n  /**\n   * Emitted when the content is fully scrolled to the bottom.\n   */\n  @Event() scrolledBottom!: EventEmitter<void>;\n\n  componentDidRender() {\n    if (this.scrollElement) {\n      this.scrolled = fromEvent(this.scrollElement, 'scroll').pipe(takeUntil(this.destroyed));\n    }\n    this.attachEmitter('left', this.scrolledLeft, this.scrolledBuffer);\n    this.attachEmitter('right', this.scrolledRight, this.scrolledBuffer);\n    this.attachEmitter('bottom', this.scrolledBottom, this.scrolledBuffer);\n    this.attachEmitter('top', this.scrolledTop, this.scrolledBuffer);\n    merge(this.init, this.scrolled)\n      .pipe(\n        map(() => ({\n          top: this.getScrollOffset('top') > 0,\n          left: this.getScrollOffset('left') > 0,\n          right: this.getScrollOffset('right') > 0,\n          bottom: this.getScrollOffset('bottom') > 0\n        })),\n        distinctUntilChanged(),\n        takeUntil(this.destroyed)\n      )\n      .subscribe(({ top, left, right, bottom }) => {\n        this.toggleClass('cat-scrollable-top', top);\n        this.toggleClass('cat-scrollable-left', left);\n        this.toggleClass('cat-scrollable-right', right);\n        this.toggleClass('cat-scrollable-bottom', bottom);\n      });\n  }\n\n  componentDidLoad() {\n    if (this.scrolledInit) {\n      this.init.next();\n    }\n  }\n\n  disconnectedCallback() {\n    this.init.complete();\n    this.destroyed.next();\n    this.destroyed.complete();\n  }\n\n  render() {\n    return [\n      <div class=\"scrollable-wrapper\" ref={el => (this.scrollWrapperElement = el)}>\n        {this.shadowY && <div class=\"shadow-top\"></div>}\n        {this.shadowX && <div class=\"shadow-left\"></div>}\n        {this.shadowX && <div class=\"shadow-right\"></div>}\n        {this.shadowY && <div class=\"shadow-bottom\"></div>}\n      </div>,\n      <div\n        ref={el => (this.scrollElement = el)}\n        class={{\n          'scrollable-content': true,\n          'scroll-x': this.overflowX,\n          'scroll-y': this.overflowY,\n          'no-overscroll': !this.overscroll\n        }}\n      >\n        <slot></slot>\n      </div>\n    ];\n  }\n\n  private attachEmitter(from: 'top' | 'left' | 'right' | 'bottom', emitter: EventEmitter<void>, buffer: number) {\n    merge(this.init, this.scrolled)\n      .pipe(map(() => this.getScrollOffset(from)))\n      .pipe(map(offset => offset <= buffer))\n      .pipe(distinctUntilChanged())\n      .pipe(filter(isLower => isLower))\n      .pipe(takeUntil(this.destroyed))\n      .subscribe(() => emitter.emit());\n  }\n\n  private getScrollOffset(from: 'top' | 'left' | 'right' | 'bottom') {\n    if (this.scrollElement) {\n      switch (from) {\n        case 'top':\n          return this.scrollElement.scrollTop;\n        case 'left':\n          return this.scrollElement.scrollLeft;\n        case 'right':\n          return this.scrollElement.scrollWidth - this.scrollElement.clientWidth - this.scrollElement.scrollLeft;\n        case 'bottom':\n          return this.scrollElement.scrollHeight - this.scrollElement.clientHeight - this.scrollElement.scrollTop;\n        default:\n          return 0;\n      }\n    }\n    return 0;\n  }\n\n  private toggleClass(name: string, value: boolean) {\n    if (value) {\n      this.scrollWrapperElement?.classList.add(name);\n    } else {\n      this.scrollWrapperElement?.classList.remove(name);\n    }\n  }\n}\n","@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  /**\n   * @prop --background: The background color of the skeleton.\n   * @prop --highlight: The highlight color of the skeleton.\n   * @prop --speed: The animation speed.\n   */\n  display: flex;\n  flex-direction: column;\n  position: relative;\n\n  --background: #{cat-token('color.ui.background.skeleton')};\n  --highlight: #{cat-token('color.ui.background.skeletonHighlight')};\n  --speed: 2s;\n}\n\n:host([variant='square']),\n:host([variant='circle']) {\n  display: inline-flex;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n:host([variant='head']) {\n  margin-bottom: $cat-head-margin-bottom;\n}\n\n:host([variant='body']) {\n  margin-bottom: $cat-body-margin-bottom;\n}\n\n.cat-skeleton {\n  display: block;\n  border-radius: cat-border-radius('m');\n  background: var(--background);\n}\n\n.cat-skeleton-circle {\n  border-radius: 10rem;\n}\n\n// ----- size\n\n@mixin size($size, $lvl) {\n  $-text-offset: 4px;\n  .cat-skeleton-#{$size} {\n    &.cat-skeleton-rectangle {\n      width: var(--width, 100%);\n      height: var(--height, #{cat-size($size)});\n    }\n\n    &.cat-skeleton-square,\n    &.cat-skeleton-circle {\n      width: var(--width, #{cat-size($size)});\n      height: var(--height, #{cat-size($size)});\n    }\n\n    &.cat-skeleton-head,\n    &.cat-skeleton-body {\n      width: var(--width, var(--line-width, 100%));\n    }\n\n    &.cat-skeleton-head {\n      height: calc(#{cat-head-font-size($lvl)} - #{$-text-offset});\n      margin: calc((#{cat-head-line-height($lvl)} - #{cat-head-font-size($lvl)} + #{$-text-offset}) * 0.5) 0;\n    }\n\n    &.cat-skeleton-body {\n      height: calc(#{cat-body-font-size($size)} - #{$-text-offset});\n      margin: calc((#{cat-body-line-height($size)} - #{cat-body-font-size($size)} + #{$-text-offset}) * 0.5) 0;\n    }\n  }\n}\n\n@include size('xs', 5);\n@include size('s', 4);\n@include size('m', 3);\n@include size('l', 2);\n@include size('xl', 1);\n\n// ----- animation\n\n.cat-skeleton-sheen {\n  background: linear-gradient(90deg, var(--background) 33%, var(--highlight) 50%, var(--background) 66%)\n    var(--background);\n  background-size: 300% 100%;\n  animation: sheen var(--speed) ease-in-out infinite;\n}\n\n.cat-skeleton-pulse {\n  position: relative;\n  overflow: hidden;\n\n  &::before {\n    content: '';\n    display: block;\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    background-color: var(--highlight);\n    animation: var(--speed) ease-in-out 0.5s infinite normal none running pulse;\n    opacity: 0;\n  }\n}\n\n@keyframes sheen {\n  0% {\n    background-position: right;\n  }\n}\n\n@keyframes pulse {\n  50% {\n    opacity: 1;\n  }\n}\n","import { Component, Host, h, Prop } from '@stencil/core';\n\n/**\n * Skeletons are used to show where content will eventually be drawn.\n */\n@Component({\n  tag: 'cat-skeleton',\n  styleUrl: 'cat-skeleton.scss',\n  shadow: true\n})\nexport class CatSkeleton {\n  /**\n   * The animation style of the skeleton.\n   */\n  @Prop() effect: 'plain' | 'sheen' | 'pulse' = 'sheen';\n\n  /**\n   * The rendering style of the skeleton.\n   */\n  @Prop() variant: 'rectangle' | 'square' | 'circle' | 'head' | 'body' = 'rectangle';\n\n  /**\n   * The size of the skeleton. If the variant is set to \"head\", the size values\n   * \"xs\" to \"xl\" translate to the head levels `h1` to `h5`.\n   */\n  @Prop() size: 'xs' | 's' | 'm' | 'l' | 'xl' = 'm';\n\n  /**\n   * The number of text lines to be rendered for \"head\" and \"body\" variants.\n   * Defaults to 1 for \"head\" and 3 for \"body\". Will be ignored for other\n   * variants.\n   */\n  @Prop() lines?: number;\n\n  render() {\n    return (\n      <Host>\n        {Array.from(Array(this.count)).map(() => (\n          <div\n            style={this.style}\n            class={{\n              'cat-skeleton': true,\n              [`cat-skeleton-${this.effect}`]: Boolean(this.effect),\n              [`cat-skeleton-${this.variant}`]: Boolean(this.variant),\n              [`cat-skeleton-${this.size}`]: Boolean(this.size)\n            }}\n          ></div>\n        ))}\n      </Host>\n    );\n  }\n\n  private get count() {\n    switch (this.variant) {\n      case 'head':\n        return Math.max(1, this.lines || 1);\n      case 'body':\n        return Math.max(1, this.lines || 3);\n      default:\n        return 1;\n    }\n  }\n\n  private get style() {\n    return this.variant === 'head' || this.variant === 'body'\n      ? {\n          '--line-width': `${this.random(50, 100)}%`\n        }\n      : undefined;\n  }\n\n  private random(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }\n}\n","@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  display: inline-flex;\n  vertical-align: middle;\n  @include cat-select(none);\n\n  &[hidden] {\n    display: none;\n  }\n}\n\nspan {\n  display: inline-flex;\n}\n\nsvg {\n  fill: none;\n  stroke: currentColor;\n  stroke-dasharray: 135px;\n  stroke-dashoffset: 95px;\n  stroke-linecap: round;\n  stroke-width: 5px;\n  transform-origin: center center;\n  animation: cat-spinner 0.75s cubic-bezier(0.4, 0.15, 0.6, 0.85) infinite;\n  width: 1em;\n  height: 1em;\n}\n\n// ----- sizes\n\n@mixin size($size) {\n  .cat-spinner-#{$size} svg {\n    font-size: cat-size($size) * 0.5;\n  }\n}\n\n@include size('xs');\n@include size('s');\n@include size('m');\n@include size('l');\n@include size('xl');\n\n// ----- animation\n\n@keyframes cat-spinner {\n  from {\n    transform: rotate(0deg);\n  }\n\n  to {\n    transform: rotate(360deg);\n  }\n}\n","import { Component, h, Prop } from '@stencil/core';\n\n/**\n * Spinners are used to indicate users that their action is being processed.\n */\n@Component({\n  tag: 'cat-spinner',\n  styleUrl: 'cat-spinner.scss',\n  shadow: true\n})\nexport class CatSpinner {\n  /**\n   * The size of the spinner.\n   */\n  @Prop() size: 'xs' | 's' | 'm' | 'l' | 'xl' | 'inline' = 'm';\n\n  /**\n   * Adds accessible label for the spinner that is only shown for screen\n   * readers. The `aria-hidden` attribute will be set if no label is present.\n   */\n  @Prop({ attribute: 'a11y-label' }) a11yLabel?: string;\n\n  render() {\n    return (\n      <span\n        aria-label={this.a11yLabel}\n        aria-hidden={this.a11yLabel ? null : 'true'}\n        class={{\n          [`cat-spinner-${this.size}`]: this.size !== 'inline'\n        }}\n      >\n        <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 48 48\">\n          <circle cx=\"24\" cy=\"24\" r=\"21.5\"></circle>\n        </svg>\n      </span>\n    );\n  }\n}\n","const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n\nexport default isTouchDevice;\n","@use 'variables' as *;\n@use 'mixins' as *;\n\n:host {\n  display: contents;\n}\n\n:host([hidden]) {\n  display: none;\n}\n\n.tooltip {\n  position: absolute;\n  @include cat-body('s');\n  padding: 0.25rem;\n  background-color: rgba(cat-token('color.ui.background.tooltip'), cat-token('opacity.tooltip'));\n  border-radius: cat-border-radius('s');\n  color: cat-token('color.ui.font.tooltip');\n  white-space: nowrap;\n  transition: cat-token('time.transition.s') linear;\n  visibility: hidden;\n  opacity: 0;\n\n  &-show {\n    opacity: 1;\n    visibility: visible;\n  }\n}\n\n.tooltip-trigger {\n  display: inline-block;\n\n  &:focus {\n    outline: none;\n  }\n}\n","import { Component, h, Host, Listen, Prop } from '@stencil/core';\nimport { autoUpdate, computePosition, flip, offset, Placement } from '@floating-ui/dom';\nimport isTouchScreen from '../../utils/is-touch-screen';\nimport firstTabbable from '../../utils/first-tabbable';\nimport { FocusableElement } from 'tabbable';\n\nlet nextUniqueId = 0;\n\n@Component({\n  tag: 'cat-tooltip',\n  styleUrl: 'cat-tooltip.scss',\n  shadow: true\n})\nexport class CatTooltip {\n  private static readonly OFFSET = 4;\n  private readonly id = `cat-tooltip-${nextUniqueId++}`;\n  private tooltip?: HTMLElement;\n  private triggerElement?: HTMLElement;\n  private trigger?: FocusableElement;\n  private showTimeout?: number;\n  private hideTimeout?: number;\n  private touchTimeout?: number;\n\n  /**\n   * The content of the tooltip.\n   */\n  @Prop() content = '';\n\n  /**\n   * Specifies that the tooltip should be disabled. A disabled tooltip is unusable,\n   * and invisible. Corresponds with the native HTML disabled attribute.\n   */\n  @Prop() disabled = false;\n\n  /**\n   * The placement of the tooltip.\n   */\n  @Prop() placement: Placement = 'top';\n\n  /**\n   * The delay time for showing tooltip in ms.\n   */\n  @Prop() showDelay = 1000;\n\n  /**\n   * The delay time for hiding tooltip in ms.\n   */\n  @Prop() hideDelay = 0;\n\n  /**\n   * The duration of tap to show the tooltip.\n   */\n  @Prop() longTouchDuration = 1000;\n\n  @Listen('keydown')\n  handleKeyDown({ key }: KeyboardEvent) {\n    key === 'Escape' && this.hideListener();\n  }\n\n  componentDidLoad(): void {\n    this.trigger = firstTabbable(this.triggerElement) || this.triggerElement;\n    if (!this.isTabbable) {\n      this.trigger?.setAttribute('tabindex', '0');\n    }\n    if (this.trigger && this.tooltip) {\n      autoUpdate(this.trigger, this.tooltip, () => this.update());\n    }\n\n    if (isTouchScreen) {\n      this.trigger?.addEventListener('touchstart', this.touchStartListener.bind(this));\n      this.trigger?.addEventListener('touchend', this.touchEndListener.bind(this));\n    } else {\n      this.trigger?.addEventListener('focusin', this.showListener.bind(this));\n      this.trigger?.addEventListener('focusout', this.hideListener.bind(this));\n      this.trigger?.addEventListener('mouseenter', this.showListener.bind(this));\n      this.trigger?.addEventListener('mouseleave', this.hideListener.bind(this));\n    }\n  }\n\n  disconnectedCallback(): void {\n    if (isTouchScreen) {\n      this.trigger?.removeEventListener('touchstart', this.touchStartListener.bind(this));\n      this.trigger?.removeEventListener('touchend', this.touchEndListener.bind(this));\n    } else {\n      this.trigger?.removeEventListener('mouseenter', this.showListener.bind(this));\n      this.trigger?.removeEventListener('mouseleave', this.hideListener.bind(this));\n      this.trigger?.removeEventListener('focusin', this.showListener.bind(this));\n      this.trigger?.removeEventListener('focusout', this.hideListener.bind(this));\n    }\n  }\n\n  render() {\n    return (\n      <Host>\n        <div ref={el => (this.triggerElement = el)} aria-describedby={this.id} class=\"tooltip-trigger\">\n          <slot />\n        </div>\n        {this.content && !this.disabled && (\n          <div ref={el => (this.tooltip = el)} id={this.id} class=\"tooltip\">\n            {this.content}\n          </div>\n        )}\n      </Host>\n    );\n  }\n\n  private get isTabbable() {\n    return firstTabbable(this.trigger);\n  }\n\n  private update() {\n    if (this.trigger && this.tooltip) {\n      computePosition(this.trigger, this.tooltip, {\n        placement: this.placement,\n        middleware: [offset(CatTooltip.OFFSET), flip()]\n      }).then(({ x, y }) => {\n        if (this.tooltip) {\n          Object.assign(this.tooltip.style, {\n            left: `${Math.max(0, x)}px`,\n            top: `${y}px`\n          });\n        }\n      });\n    }\n  }\n\n  private showListener() {\n    window.clearTimeout(this.hideTimeout);\n    this.showTimeout = window.setTimeout(() => {\n      this.trigger?.focus();\n      this.tooltip?.classList.add('tooltip-show');\n    }, this.showDelay);\n  }\n\n  private hideListener() {\n    window.clearTimeout(this.showTimeout);\n    this.hideTimeout = window.setTimeout(() => {\n      this.trigger?.blur();\n      this.tooltip?.classList.remove('tooltip-show');\n    }, this.hideDelay);\n  }\n\n  private touchStartListener() {\n    this.touchTimeout = window.setTimeout(() => {\n      this.tooltip?.classList.add('tooltip-show');\n    }, this.longTouchDuration);\n  }\n\n  private touchEndListener() {\n    window.clearTimeout(this.touchTimeout);\n    this.tooltip?.classList.remove('tooltip-show');\n  }\n}\n"]}